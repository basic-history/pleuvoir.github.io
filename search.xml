<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker入门</title>
      <link href="/2019/05/24/docker-ru-men/"/>
      <url>/2019/05/24/docker-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>docker支持CentOS6 及以后的版本。</p><p>如果之前安装过则先卸载，如果是第一次安装则可跳过</p><pre><code>## 查询是否安装过dockeryum list installed | grep docker## 删除安装过的docker如果有的话yum -y remove docker-engine.x86_64## 删除镜像容器rm -rf /var/lib/docker</code></pre><p>这里<code>docker-engine.x86_64</code>即为查询出的一个结果</p><p>在不同的linux版本上安装方式不太相同，因为centos7自带了docker。查看linux版本，<code>cat /etc/redhat-release</code></p><ol><li>如果是centos6：</li></ol><pre><code>sudo yum install http://mirrors.yun-idc.com/epel/6/i386/epel-release-6-8.noarch.rpmsudo yum install docker-io</code></pre><ol start="2"><li>如果是centos7：</li></ol><pre><code>## 安装最新版## sudo yum install docker 这样安装不是最新版sudo yum install -y yum-utils device-mapper-persistent-data lvm2## 配置仓库速度更快sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo sudo yum install docker-ce </code></pre><p>查看docker版本</p><pre><code>docker version</code></pre><p>提示<code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code>，因为我们没有安装daemon。</p><p>启动docker</p><pre><code>sudo service docker start</code></pre><p>查看docker信息</p><pre><code>docker info</code></pre><p>设置随系统开机启动</p><pre><code>sudo chkconfig docker on</code></pre><p>至此安装完成。</p><ol start="3"><li>windows</li></ol><p><a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a></p><p>如果不是window10，可以使用boot2Docker工具</p><h3 id="docker体验"><a href="#docker体验" class="headerlink" title="docker体验"></a>docker体验</h3><p>入门hello-world镜像</p><pre><code>docker run hello-world </code></pre><p>会出现以下画面：</p><pre><code>Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><p>恭喜，成功来到了docker世界。其中<code>hello-world</code>是官方提供的一个镜像。</p><h3 id="docker基本操作"><a href="#docker基本操作" class="headerlink" title="docker基本操作"></a>docker基本操作</h3><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><p>docker images|rmi|tag|build|history|save|load]</p><ul><li>images：列出本地镜像列表</li><li>rmi [镜像名：版本]：删除镜像</li><li>tag [镜像名：版本] [仓库]/[镜像名：版本]：标记本地镜像，将其归入某一仓库</li><li>build -t [镜像名：版本] [path]：Dockerfile 创建镜像</li><li>history [镜像名：版本]: 查看指定镜像的创建历史</li><li>save -o xxx.tar [镜像名：版本] /  save [镜像名：版本]&gt;xxx.tar : 将镜像保存成 tar 归档文件</li><li>load –input  xx.tar / docker load&lt;xxx.tar : 从归档文件加载镜像</li></ul><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><h5 id="容器生命周期管理"><a href="#容器生命周期管理" class="headerlink" title="容器生命周期管理"></a>容器生命周期管理</h5><p>docker [run|start|stop|restart|kill|rm|pause|unpause]</p><ul><li>run/create[镜像名]：  创建一个新的容器并运行一个命令</li><li>start/stop/restart[容器名]：启动/停止/重启一个容器</li><li>kill [容器名]： 直接杀掉容器，不给进程响应时间</li><li>rm[容器名]：删除已经停止的容器</li><li>pause/unpause[容器名]：暂停/恢复容器中的进程</li></ul><h5 id="容器运维"><a href="#容器运维" class="headerlink" title="容器运维"></a>容器运维</h5><p>docker [ps|inspect|exec|logs|export|import]</p><ul><li>ps：查看容器列表（默认查看正在运行的容器，-a查看所有容器）</li><li>inspect[容器名]：查看容器配置元数据</li><li>exec -it [容器名] /bin/bash：进入容器环境中交互操作</li><li>logs –since=”2019-02-01” -f –tail=10 [容器名]:查看容器日志 </li><li>cp path1 [容器名]:path 容器与主机之间的数据拷贝</li><li>export -o test.tar [容器名] / docker export [容器名]&gt;test.tar : 文件系统作为一个tar归档文件</li><li>import test.tar [镜像名:版本号]:导入归档文件，成为一个镜像</li></ul><h4 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h4><ul><li>docker [login|pull|push|search] </li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><pre><code class="bash">#查看所有镜像docker images#下载centos镜像docker pull centos #第一种启动进入方式（前台运行）：启动容器并进入内部交互环境docker run -it --name centos1 centos /bin/bash#退出 ctrl+p+q会退出但不关闭容器 如果直接exit会关闭容器 #现在没有退出，在外部退出（优雅关闭，也可以直接kill）docker stop centos1#再次启动,但不会进入shelldocker start centos1#第二种启动进入方式（后台运行，-d代表后台运行，但必须配合it使用,it会拉起前端进程不会导致它自动退出）docker run -dit --name centos1 centos#再次进入docker exec -it centos1 /bin/bash# 查看容器的元数据信息docker inspect centos1#查看正在运行的容器docker ps#查看所有容器docker ps -a#删除容器（可以批量删除）docker rm b098c66ef455 9e995983f718 b88bafdf8715#删除镜像docker rmi 9e995983f718</code></pre><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ol><li><p>下载镜像特别慢？</p><p>配置daemon地址为国内。</p><pre><code class="bash">vi /etc/docker/daemon.json增加内容，直接复制即可，这个文件可能没有创建即可{  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]}#重启service docker restart</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-线程池</title>
      <link href="/2019/04/14/bing-fa-bian-cheng-xian-cheng-chi/"/>
      <url>/2019/04/14/bing-fa-bian-cheng-xian-cheng-chi/</url>
      
        <content type="html"><![CDATA[<p>不讲概念，来记录下常见线程池的配置以及区别。</p><p>先来回顾下常见的配置参数：</p><pre><code class="java">public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory)</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>该方法返回一个固定大小的线程池，该线程从中的线程数量固定不变，当有任务提交时如果有空闲线程，立即执行，否则加入等待队列，直到有空闲线程时再执行。</p><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;(),                                  threadFactory);}</code></pre><p>可以看到<code>corePoolSize=maximumPoolSize</code>，并且等待队列大小为<code>Integer.MAX_VALUE</code>，也就是说这是一个固定大小的线程池，可以无限接收任务直到服务器挂了。</p><p>示例：</p><pre><code class="java">ExecutorService pool = Executors.newFixedThreadPool(3, new ThreadFactory() {    AtomicLong count = new AtomicLong(1);    @Override    public Thread newThread(Runnable r) {        Thread thread = new Thread(r);        thread.setName(&quot;nameThreadFactory-&quot; + count.getAndIncrement());        return thread;    }});int i = 0;for (; i &lt; 10; i++) {    pool.execute(() -&gt; {        System.out.println(Thread.currentThread().getName() + &quot; go&quot;);    });}//必须结束，否则线程无法关闭pool.shutdown();</code></pre><p>console output:</p><pre><code>nameThreadFactory-1 gonameThreadFactory-3 gonameThreadFactory-2 gonameThreadFactory-1 gonameThreadFactory-3 gonameThreadFactory-2 gonameThreadFactory-3 gonameThreadFactory-1 gonameThreadFactory-3 gonameThreadFactory-2 go</code></pre><p>可以看出来来回回只有三个线程在切换执行。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>该方法返回一个可根据实际情况调整数量的线程池，数量不固定，但优先会复用线程，如果当前线程数量不够，再创建新的线程。</p><pre><code class="java">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;(),                                  threadFactory);}</code></pre><p>初始大小为0，最大大小无上限，也就代表了可以一直创建新的线程，这里的等待队列<code>SynchronousQueue</code>比较特殊，是一个直接提交的队列，不会保存即总是将任务交给线程执行，也就是说<code>newCachedThreadPool</code>是不带缓冲队列的。</p><p>示例：</p><pre><code class="java">ExecutorService pool = Executors.newCachedThreadPool(new ThreadFactory() {    AtomicLong count = new AtomicLong(1);    @Override    public Thread newThread(Runnable r) {        Thread thread = new Thread(r);        thread.setName(&quot;nameThreadFactory-&quot; + count.getAndIncrement());        return thread;    }});int i = 0;for (; i &lt; 10; i++) {    pool.execute(() -&gt; {        System.out.println(Thread.currentThread().getName() + &quot; go&quot;);    });}//必须结束，否则线程无法关闭pool.shutdown();</code></pre><p>console output:</p><pre><code>nameThreadFactory-1 gonameThreadFactory-2 gonameThreadFactory-3 gonameThreadFactory-4 gonameThreadFactory-5 gonameThreadFactory-6 gonameThreadFactory-7 gonameThreadFactory-8 gonameThreadFactory-4 gonameThreadFactory-8 go</code></pre><p>可以看出有重复的线程在执行任务，这就是复用的表现。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>定时调度的线程池在中间件研发中经常会被使用到，其中主要包含三个方法：</p><pre><code class="java">//将在delay单位的延迟后开始执行一次任务public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit);//以固定的速率执行任务，initialDelay代表第一次执行需要延迟的时间，period代表多久重复一次public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit);//以固定的延迟周期执行任务，即每个任务执行相差delay时间public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit);</code></pre><pre><code class="java">ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3, new ThreadFactory() {    AtomicLong count = new AtomicLong(1);    @Override    public Thread newThread(Runnable r) {        Thread thread = new Thread(r);        thread.setName(&quot;nameThreadFactory-&quot; + count.getAndIncrement());        return thread;    }});Runnable task = new Runnable() {    @Override    public void run() {        System.out.println(Thread.currentThread().getName() + &quot; time：&quot; + System.currentTimeMillis() + &quot; go&quot;);    }};Runnable scheduleAtFixedRateTask = new Runnable() {    @Override    public void run() {        System.out.println(&quot;scheduleAtFixedRateTask&quot; + &quot; begin time：&quot; + System.currentTimeMillis() + &quot; go&quot;);        try {            TimeUnit.SECONDS.sleep(3);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;scheduleAtFixedRateTask&quot; + &quot; end   time：&quot; + System.currentTimeMillis() + &quot; go&quot;);    }};// 1秒过后执行scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS);// 1秒以后开始启动，每过两秒执行一次，如果上一个工作超过了2秒，那么下一个并不会开始，而是等到上一个结束后立马开始。scheduledThreadPool.scheduleAtFixedRate(scheduleAtFixedRateTask, 1, 2, TimeUnit.SECONDS);// 1秒以后开始启动，每个任务之间间隔2秒，无论上一个任务执行了多久，下一个任务总是会在上一个任务结束后2秒开始。scheduledThreadPool.scheduleWithFixedDelay(task, 1, 2, TimeUnit.SECONDS);// 结束后，两个定时执行的都无法工作// scheduledThreadPool.shutdown();}</code></pre><p>以上程序的输出就不再展示了，简单说下现象：</p><p><code>scheduledThreadPool.schedule(task, 1, TimeUnit.SECONDS);</code>会在一秒后执行一次结束。</p><p><code>scheduledThreadPool.scheduleAtFixedRate(scheduleAtFixedRateTask, 1, 2, TimeUnit.SECONDS);</code>就比较有意思了，这里设定的是程序开始一秒后开始执行第一次计划任务，每隔2秒重复一次。如果任务执行时间小于2秒，那自然没什么问题。但是这里设置的任务时长为3秒，会发现上一个任务没结束，即使到了2秒的间隔，下一个也不会开始，而是痴情的等待上一个任务的结束，只要它一结束，下一个会立刻开始。</p><pre><code>scheduleAtFixedRateTask begin time：1555324763580 goscheduleAtFixedRateTask end   time：1555324766581 goscheduleAtFixedRateTask begin time：1555324766581 go</code></pre><p>输出就是如此这般。</p><p><code>scheduledThreadPool.scheduleWithFixedDelay(task, 1, 2, TimeUnit.SECONDS);</code>是比较好理解的，无论上一个任务执行多久，只要它一结束后再过2秒，下一个任务即开始，没什么特殊的地方。</p><h3 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h3><p>由于对线程池的实现比较熟悉，所以不再进行详细的记录，简单的记录下要注意的地方：</p><p>1) 饱和策略</p><p>当线程池负载高，无法处理新投递的任务时有几种拒绝策略：</p><ol><li>抛出异常</li><li>谁调用谁执行</li><li>丢弃队列中最老的任务，也就是即将执行的任务</li><li>直接丢弃当前任务</li></ol><p>2） 注意异常</p><p>当任务的执行过程中如果发生了异常，那么后续的任务将不会在执行，所以一定要注意<code>try-catch</code>异常，这是好的编程实践。</p><p>3）线程数设置多大</p><p>一般IO密集型CPU*2，计算密集型CPU+1</p><p>4） 丢失的异常堆栈</p><p>如果执行的任务报错了，并且刚好没有捕获任何异常，那么不好意思，堆栈丢了，要么自己捕获<code>Runable</code>，要么扩展线程池，可以看看<code>Guava</code>中对线程池的扩展，或者唯品会的<code>vipTools</code>。</p><h3 id="如果有人问线程池是咋回事，你就这么说"><a href="#如果有人问线程池是咋回事，你就这么说" class="headerlink" title="如果有人问线程池是咋回事，你就这么说"></a>如果有人问线程池是咋回事，你就这么说</h3><p>曾经有一个创业公司，它就是线程池。开张的时候拉了4个兄弟，就是coreSize=4，后来公司发展的太快，需求越来越多，兄弟们忙不过来了，怎么办只能任务排期了，但排期总有个上限吧，不能压着10000个需求不做吧？这个个数呢就是队列的长度。这个时候公司扩招了，技术部最多招30个兄弟。好了，兄弟们来了，10000个需求也搞完了。这个时候呢，9012年了经济危机了资本家不乐意了，公司不养闲人啊，那个老王，你看你们技术部那些新来的（maxSize-coreSize）有哪些一个月没干活了（aliveTime）开了吧。呵呵。。</p><p>纪念下那些被开的兄弟。（刘强东说了不能奋斗的人都不是我的兄弟）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-阻塞队列</title>
      <link href="/2019/04/14/bing-fa-bian-cheng-zu-sai-dui-lie/"/>
      <url>/2019/04/14/bing-fa-bian-cheng-zu-sai-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>今天来看一下JDK中的阻塞队列，这个容器也很重要，因为我们做消息中间件必须用到。</p><p>什么是阻塞队列？就是给普通的队列增加阻塞操作。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>JAVA里提供了7个阻塞队列，分别是：</p><ul><li>ArrayBlockingQueue：一个由数据结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriortyBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>是用一个数组实现的有界阻塞队列，是一个<code>FIFO</code>队列。默认是非公平的（不按照线程阻塞的顺序插入或者弹出）。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code>一个由链表结构组成的有界阻塞队列，此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>，也是一个<code>FIFO</code>队列。</p><h4 id="PriortyBlockingQueue"><a href="#PriortyBlockingQueue" class="headerlink" title="PriortyBlockingQueue"></a>PriortyBlockingQueue</h4><p><code>PriortyBlockingQueue</code>是一个支持优先级排序的无界阻塞队列，默认按照元素自然顺序升序排列。也可以自定类实现<code>compareTo()</code>来指定排序规则。或者初始化时，指定构造参数<code>Comparator</code>来对元素进行排序。需要注意的是，如果两个元素优先级相同，不能保证它们的顺序。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p><code>DelayQueue</code>是一个支持延时获取元素的无界阻塞队列。队列使用<code>PriortyBlockingQueue</code>来实现。队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才可以提取元素。</p><p>介绍一下<code>DelayQueue</code>的用途：</p><ol><li><p>缓存系统的设计</p><p>可以用<code>DelayQueue</code>来保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>，一旦从<code>DelayQueue</code>中获取到数据，则说明这个缓存有效期到了。</p></li><li><p>定时任务调度</p><p>使用<code>DelayQueue</code>保存当天将会执行的任务和时间，一旦从<code>DelayQueue</code>获取到任务就开始执行。比如<code>TimerQueue</code>就是基于<code>DelayQueue</code>实现的。</p></li></ol><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p><code>SynchronousQueue</code>是一个不存储元素的阻塞队列，每一个<code>put</code>操作必须等待一个<code>take</code>操作，否则不能继续添加元素。默认是非公平的。这个队列比较特殊，可以认为是一个传球手，负责把生产者处理的数据直接传递给消费者线程。队列本身不存储任何元素，非常适合传递性场景。<code>SynchronousQueue</code>的吞吐量高于<code>ArrayBlockingQueue</code>和<code>LinkedBlockingQueue</code>。在<code>cacheThreadPool</code>中就是用了这种队列。</p><h4 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h4><p><code>LinkedTransferQueue</code>是一个由链表结构组成的无界阻塞队列。相对于其他队列，它多了两个方法：<code>transfer()和tryTransfer()</code>。如果有消费者需要拿元素，<code>transfer()</code>方法可以把生产者传入的元素立即传给消费者；如果没有，则会把元素放在<code>tail</code>节点，等到该元素被消费了才返回，也就是说<code>transfer()</code>必须等到消费者消费了才返回，<code>tryTransfer()</code>顾名思义，尝试传输，不用等待如果传输失败直接返回false。</p><h4 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h4><p><code>LinkedBlockingDeque</code>是一个由链表结构组成的双向阻塞队列，所谓双向就是可以队尾和队头插入和弹出元素。在初始化时可以设置容量，防止过度膨胀。双向阻塞队列可以用在工作窃取中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实知道多线程几种阻塞机制，很容易就能实现阻塞的功能，比如<code>wait-notify</code>，<code>reentrantLock.condition</code>和<code>LockSupport.park(this)</code>，其实阻塞队列也就是这几种模式实现的。</p><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h4><p>使用<code>BlockingQueue</code>实现生产者-消费者模式进行解耦。</p><p>生产者，发出求救信号:</p><pre><code class="java">public class SOSProducer implements Runnable {    private BlockingQueue&lt;SOSData&gt; queue;    public SOSProducer(BlockingQueue&lt;SOSData&gt; queue) {        this.queue = queue;    }    @Override    public void run() {        for (;;) {            try {                long waiting = ThreadLocalRandom.current().nextLong(5);                TimeUnit.SECONDS.sleep(waiting);                queue.put(new SOSData(System.currentTimeMillis()));            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p>消费者，接收求救信号并打印：</p><pre><code class="java">public class SOSConsumer implements Runnable {    private BlockingQueue&lt;SOSData&gt; queue;    public SOSConsumer(BlockingQueue&lt;SOSData&gt; queue) {        this.queue = queue;    }    @Override    public void run() {        for (;;) {            try {                SOSData data = queue.take();                System.out.println(Thread.currentThread().getName() + &quot; 接收到求救信号：&quot; + data);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}</code></pre><p>客户端:</p><pre><code class="java">private static final int PRODUCER_THREAD_NUM = 10;private static final int CONSUMER_THREAD_NUM = 2;public static void main(String[] args) {    BlockingQueue&lt;SOSData&gt; queue = new LinkedBlockingQueue&lt;SOSData&gt;(100);    ExecutorService producerPool = Executors.newFixedThreadPool(PRODUCER_THREAD_NUM);    ExecutorService consumerPool = Executors.newFixedThreadPool(CONSUMER_THREAD_NUM);    for (int i = 0; i &lt; PRODUCER_THREAD_NUM; i++) {        producerPool.execute(new SOSProducer(queue));    }    for (int i = 0; i &lt; CONSUMER_THREAD_NUM; i++) {        consumerPool.execute(new SOSConsumer(queue));    }}</code></pre><p>console output:</p><pre><code>pool-2-thread-2 接收到求救信号：SOSData [sosTime=1555426748063]pool-2-thread-1 接收到求救信号：SOSData [sosTime=1555426748063]pool-2-thread-2 接收到求救信号：SOSData [sosTime=1555426748064]pool-2-thread-1 接收到求救信号：SOSData [sosTime=1555426748064]pool-2-thread-2 接收到求救信号：SOSData [sosTime=1555426748063]pool-2-thread-1 接收到求救信号：SOSData [sosTime=1555426749063]pool-2-thread-2 接收到求救信号：SOSData [sosTime=1555426750063]pool-2-thread-1 接收到求救信号：SOSData [sosTime=1555426750063]pool-2-thread-2 接收到求救信号：SOSData [sosTime=1555426750063]</code></pre><h4 id="延迟订单"><a href="#延迟订单" class="headerlink" title="延迟订单"></a>延迟订单</h4><p>使用<code>delayQueue</code>实现，其实这种基于内存的不太可靠，这里演示下用法，方便写demo时使用：</p><pre><code class="java">/** * 延迟元素 * */public class DelayItem&lt;T&gt; implements Delayed {    /**     * 到期时间（执行时间）单位纳秒     */    private long executeTime;    /**     * 数据     */    private T data;    // time是过期时长，也就是延迟多少毫秒 5*1000即为5秒    public DelayItem(long delayTime, T data) {        // 将传入的时长转为超时的时刻        this.executeTime = TimeUnit.NANOSECONDS.convert(delayTime, TimeUnit.MILLISECONDS) + System.nanoTime();        this.data = data;    }    // 按照剩余时间排序    @Override    public int compareTo(Delayed o) {        long d = this.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);        return (d == 0) ? 0 : (d &gt; 0 ? 1 : -1);    }    // 该方法返回还需要延时多少时间，单位为纳秒，所以设计的时候最好使用纳秒    @Override    public long getDelay(TimeUnit unit) {        return unit.convert(executeTime - System.nanoTime(), TimeUnit.NANOSECONDS);    }    public long getExecuteTime() {        return executeTime;    }    public T getData() {        return data;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文演示了下基本的阻塞队列，并没有对原理进行分析，其实实现原理并不复杂，就是基于显示锁的等待通知。</p><p>EOF</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-读写锁</title>
      <link href="/2019/04/13/bing-fa-bian-cheng-du-xie-suo/"/>
      <url>/2019/04/13/bing-fa-bian-cheng-du-xie-suo/</url>
      
        <content type="html"><![CDATA[<p>今天我们来看看，JDK提供的另外两种锁，读写锁，适用于读多写少的情况下使用，来减少并发冲突。</p><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p><code>ReadWriteLock</code>是JDK5中提供的读写分离锁。读写分离锁可以有效减少锁竞争，提升系统性能。如果使用重入锁<code>ReentrantLock</code>或者<code>synchronized</code>来实现，多个线程之间无论是，读读、写写，还是读写都是互斥的，必须得相互等待对方的锁释放。而使用读写锁读读的时候是不阻塞的，因此特别适合于读多写少的场景下使用，可以极大的提升性能。</p><p>直接看代码：</p><pre><code class="java">static ReentrantLock reentrantLock = new ReentrantLock();static ReadWriteLock readWriteLock = new ReentrantReadWriteLock();static Lock readLock = readWriteLock.readLock();static Lock writeLock = readWriteLock.writeLock();static CountDownLatch latch = new CountDownLatch(20);public static void main(String[] args) throws InterruptedException {    long start = System.currentTimeMillis();    ReadWriteLockTest readWriteLockTest = new ReadWriteLockTest();    Runnable read = new Runnable() {        @Override        public void run() {            readWriteLockTest.read();        }    };    Runnable write = new Runnable() {        @Override        public void run() {            readWriteLockTest.write();        }    };    for (int i = 0; i &lt; 18; i++) {        new Thread(read).start();    }    for (int i = 18; i &lt; 20; i++) {        new Thread(write).start();    }    latch.await();    System.out.println(&quot;cost time=&quot; + (System.currentTimeMillis() - start) / 1000 + &quot;s&quot;);}private void read() {    try {        readLock.lock();        TimeUnit.SECONDS.sleep(1); //读操作耗时越多，读写锁性能越优秀        System.out.println(Thread.currentThread().getName() + &quot; read&quot;);        latch.countDown();    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        readLock.unlock();    }}private void write() {    try {        writeLock.lock();        TimeUnit.SECONDS.sleep(1);        System.out.println(Thread.currentThread().getName() + &quot; write&quot;);        latch.countDown();    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        writeLock.unlock();    }}</code></pre><p>console output:</p><pre><code>Thread-10 readThread-9 readThread-5 readThread-7 readThread-3 readThread-8 readThread-0 readThread-6 readThread-2 readThread-4 readThread-1 readThread-14 readThread-16 readThread-17 readThread-11 readThread-15 readThread-13 readThread-12 readThread-18 writeThread-19 writecost time=3s</code></pre><p>只耗时3秒，如果读写全部使用<code>reentrantLock</code>则需要20秒。</p><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p><code>StampedLock</code>是JDK8中引进的新的锁机制，可以认为它是读写锁的一个改进版本。<code>ReadWriteLock</code>实现了读读无锁，但读写还是有冲突的，它采用的是悲观策略；如果有大量读线程还会导致写线程饥饿。而<code>StampedLock</code>则使用乐观策略，这种乐观策略非常类似乐观锁，所以读线程可以不阻塞写线程。</p><p>示例：</p><pre><code class="java">private double x, y;static CountDownLatch latch = new CountDownLatch(22);static StampedLock sl = new StampedLock();public static void main(String[] args) throws InterruptedException {    long start = System.currentTimeMillis();    StampedLockTest stampedLockTest = new StampedLockTest();    Runnable read = new Runnable() {        @Override        public void run() {            stampedLockTest.read();        }    };    Runnable write = new Runnable() {        @Override        public void run() {            ThreadLocalRandom current = ThreadLocalRandom.current();            stampedLockTest.write(current.nextDouble(), current.nextDouble());        }    };    for (int i = 0; i &lt; 20; i++) {        new Thread(read).start();        if (i % 10 == 0) {            new Thread(write).start();        }    }    latch.await();    System.out.println(&quot;cost time=&quot; + (System.currentTimeMillis() - start) / 1000 + &quot;s&quot;);}void write(double deltaX, double deltaY) {    long stamp = sl.writeLock(); // 这是一个排它锁    try {        x += deltaX;        y += deltaY;        TimeUnit.SECONDS.sleep(1);        System.out.println(Thread.currentThread().getName() + &quot; write&quot;);        latch.countDown();    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        sl.unlockWrite(stamp);    }}double read() { // 只读方法    // 尝试乐观读锁    long stamp = sl.tryOptimisticRead();    double currentX = x, currentY = y;    // 如果校验失败则代表数据类修改了    if (!sl.validate(stamp)) {        // 锁升级为悲观锁（如果有其他线程正在写，则会等待直到获取读锁）        stamp = sl.readLock();        try {            currentX = x;            currentY = y;            TimeUnit.SECONDS.sleep(1);            System.out.println(Thread.currentThread().getName() + &quot; 悲观读锁成功&quot;);            latch.countDown();            return Math.sqrt(currentX * currentX + currentY * currentY);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            sl.unlockRead(stamp);        }    }    System.out.println(Thread.currentThread().getName() + &quot; 乐观读锁成功&quot;);    latch.countDown();    return Math.sqrt(currentX * currentX + currentY * currentY);}</code></pre><p>由于测试环境为<code>Window</code>，如果使用</p><pre><code class="java">for (int i = 0; i &lt; 18; i++) {    new Thread(read).start();}for (int i = 18; i &lt; 20; i++) {    new Thread(write).start();}</code></pre><p>来启动会发现基本上不会触发悲观读锁，所以改为混合交叉启动</p><pre><code class="java">for (int i = 0; i &lt; 20; i++) {    new Thread(read).start();    if (i % 10 == 0) {        new Thread(write).start();    }}</code></pre><p>但实际上测试结果表明，和<code>ReadWriteLock</code>表现的差不多。所以平时使用时可以选择使用<code>ReadWriteLock</code>，除非是特别要求性能的情况下，可以考虑使用<code>StampedLock</code>，最起码得知道它的存在以及思路。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-ReentrantLock</title>
      <link href="/2019/04/12/bing-fa-bian-cheng-ke-chong-ru-suo-reentrantlock/"/>
      <url>/2019/04/12/bing-fa-bian-cheng-ke-chong-ru-suo-reentrantlock/</url>
      
        <content type="html"><![CDATA[<p>今天我们来看看并发编程的可重入锁<code>ReentrantLock</code>，它和关键字<code>synchronized</code>非常的相像。<code>ReentrantLock</code>可以完全替代关键字<code>synchronized</code>，JDK6以后<code>synchronized</code>进行了很多的优化，所以两者在性能上差距不大。建议能使用<code>synchronized</code>情况下优先使用，因为后续JVM还会对其实现进行持续优化。</p><p>那么它比<code>synchronized</code>有哪些优点呢？</p><p>1）支持公平锁和非公平锁：</p><p>在大多数情况下，锁的申请都是非公平的。当线程1请求了锁A，线程2之后也请求了锁A，当锁可用时，是谁获得这个锁呢？这是不一定的，系统会从锁的等待队列中随机挑选一个，因此不能保证公平性。开启公平锁模式必须要维护一个有序队列，所以会带来性能的损失。但是公平模式会保证有序性，并且不会产生饥饿现象。</p><p>2）支持响应中断以及限时获取锁：</p><p>对关键字<code>synchronized</code>而言，如果一个线程正在等待一把锁，那么结果只有两种：要么等待，要么获得锁。而<code>ReentrantLock</code>为我们提供了第三种可能，那就是响应中断（等着等着不等了），这种方式对处理死锁也是有帮助的。</p><p>限时获取锁指的是在一定时间内尝试获取锁，超时在不在获取返回false。</p><p>3）更灵活的api</p><p>这个也能算是它的一个优点，我们可以方便的控制临界区代码。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p>还是直接来看例子：</p><pre><code class="java">static ReentrantLock lock = new ReentrantLock();static int j = 0;public static void main(String[] args) throws InterruptedException {    Task first = new Task();    Task second = new Task();    first.start();    second.start();    first.join();    second.join();    System.out.println(j);}public static class Task extends Thread {    @Override    public void run() {        try {            lock.lock();            for (int i = 0; i &lt; 1000; i++) {                j++;            }        } finally {            lock.unlock();        }    }}</code></pre><p>可以看到，和<code>synchronized</code>相比，<code>ReentrantLock</code>加锁和释放锁的操作都是由开发人员手动控制的，所以它有更高的灵活性。需要注意的是，锁在使用完必须释放，否则其他线程没有机会访问到临界区了。一般我们会在<code>finally</code>中进行释放。</p><p>为什么叫可重入锁呢？看下面的代码就明白了：</p><pre><code class="java">try {    lock.lock();    lock.lock();    for (int i = 0; i &lt; 1000; i++) {        j++;    }} finally {    lock.unlock();    lock.unlock();}</code></pre><p>当获取到锁时再次进行获取是可以得到锁的，并不会因为自己已经持有了锁导致死锁。一定要注意，获取了几次便要释放几次锁。</p><h4 id="lockInterruptibly中断响应"><a href="#lockInterruptibly中断响应" class="headerlink" title="lockInterruptibly中断响应"></a>lockInterruptibly中断响应</h4><p>对关键字<code>synchronized</code>而言，如果一个线程正在等待一把锁，那么结果只有两种：要么等待，要么获得锁。而<code>ReentrantLock</code>为我们提供了第三种可能，那就是响应中断（等着等着不等了），这种方式对处理死锁也是有帮助的。</p><p>先演示一个死锁的发生：</p><pre><code class="java">static ReentrantLock lock1 = new ReentrantLock();static ReentrantLock lock2 = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    Task t1 = new Task(1);    Task t2 = new Task(2);    t1.start();    t2.start();    t1.join();}public static class Task extends Thread {    int lock; // 控制传入的锁    public Task(int lock) {        this.lock = lock;    }    @Override    public void run() {        if (lock == 1) {            try {                // 先获取lock1 再获取lock2                lock1.lock();                TimeUnit.SECONDS.sleep(1);                lock2.lock();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock1.unlock();                lock2.unlock();            }        } else {            try {                // 先获取lock2 再获取lock1                lock2.lock();                TimeUnit.SECONDS.sleep(1);                lock1.lock();            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock2.unlock();                lock1.unlock();            }        }    }}</code></pre><p>t1获得lock1的时候，t2同时获得了lock2；它们想获得的第二个锁被对方持有，因而死锁。我们将程序稍事修改，即可解决这个死锁问题。</p><pre><code class="java">static ReentrantLock lock1 = new ReentrantLock();static ReentrantLock lock2 = new ReentrantLock();public static void main(String[] args) throws InterruptedException {    Task t1 = new Task(1);    Task t2 = new Task(2);    t1.start();    t2.start();    TimeUnit.SECONDS.sleep(2);    t1.interrupt();    System.out.println(&quot;t1.interrupt()&quot;);}public static class Task extends Thread {    int lock; // 控制传入的锁    public Task(int lock) {        this.lock = lock;        setName(&quot;lock-&quot; + lock);    }    @Override    public void run() {        try {            if (lock == 1) {                // 先获取lock1 再获取lock2                lock1.lockInterruptibly();                System.out.println(Thread.currentThread().getName() + &quot;已获得获取lock1&quot;);                TimeUnit.SECONDS.sleep(1);                System.out.println(Thread.currentThread().getName() + &quot;尝试获取lock2&quot;);                lock2.lockInterruptibly();                System.out.println(Thread.currentThread().getName() + &quot;获取lock2成功，执行完毕&quot;);            } else {                // 先获取lock2 再获取lock1                lock2.lockInterruptibly();                System.out.println(Thread.currentThread().getName() + &quot;已获得获取lock2&quot;);                TimeUnit.SECONDS.sleep(1);                System.out.println(Thread.currentThread().getName() + &quot;尝试获取lock1&quot;);                lock1.lockInterruptibly();                System.out.println(Thread.currentThread().getName() + &quot;获取lock1成功，执行完毕&quot;);            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            if (lock1.isHeldByCurrentThread()) {                lock1.unlock();            }            if (lock2.isHeldByCurrentThread()) {                lock2.unlock();            }        }    }}</code></pre><p>线程可以响应中断，中断的线程会让出持有的锁，从而解决死锁的问题。这里还有个细节释放锁的时候通过<code>lock.isHeldByCurrentThread()</code>来判断，字如其意，如果这个锁被当前线程持有则释放。为什么需要这样判断，直接释放不可以吗？对不起不可以，因为线程中断的时候，锁已经被释放了，这里不判断的话会多次释放触发<code>IllegalMonitorStateException</code>。</p><h4 id="tryLock锁申请等待限时"><a href="#tryLock锁申请等待限时" class="headerlink" title="tryLock锁申请等待限时"></a>tryLock锁申请等待限时</h4><pre><code class="java">boolean tryLock();boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</code></pre><p>这两个api看着都很直观，第一个尝试获取锁失败返回false，第二个则是在一定时间内尝试获取，超时后返回false。</p><p>同样，利用这种机制也可以减少死锁的发生。</p><h4 id="重入锁的好搭档Condition"><a href="#重入锁的好搭档Condition" class="headerlink" title="重入锁的好搭档Condition"></a>重入锁的好搭档Condition</h4><p>类似于翻版的<code>wait-notify</code>，我们知道等待通知机制是配合<code>synchronized</code>先获取锁，然后才能<code>wait-notify</code>。在重入锁里也提供了这样类似实现。使用<code>Condition</code>来控制等待通知。</p><p>使用</p><pre><code class="java">void await() throws InterruptedException;void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;void signal();void signalAll();</code></pre><p>以上方法的含义如下：</p><ul><li><code>await()</code>方法会使当前线程等待，并释放当前锁。当其他线程正确使用了<code>signal()</code>或者<code>signalAll()</code>会返回。当前线程被中断，也能跳出等待。这和<code>Object.wait()</code>类似。</li><li><code>awaitUninterruptibly()</code>不会在等待过程中响应中断</li><li><code>signal()</code>唤醒一个正在等待的线程，<code>signalAll()</code>唤醒所有。这和<code>Object.notify()/notifyAll()</code>类似。</li></ul><p>来看一个示例：</p><pre><code class="java">static ReentrantLock lock = new ReentrantLock();static Condition condition = lock.newCondition();public static void main(String[] args) throws InterruptedException {    Task task1 = new Task();    Task task2 = new Task();    task2.start();    task1.start();    TimeUnit.SECONDS.sleep(3);    try {        lock.lock();    //    condition.signal();        condition.signalAll(); //通知所有        System.out.println(&quot;已通知&quot;);    } finally {        TimeUnit.SECONDS.sleep(2);        lock.unlock();    }}public static class Task extends Thread {    @Override    public void run() {        try {            lock.lock();            condition.await();            System.out.println(getName() + &quot; over..&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}</code></pre><p>console output:</p><pre><code>已通知Thread-1 over..Thread-0 over..</code></pre><p>程序运行的效果是3秒后控制台输出<code>已通知</code>，再过2秒，输出<code>Thread-0 over..和Thread-0 over..</code>。可以看出这点和我们使用等待通知是类似的（notify方法放在方法的最后一行）。通知时只有释放了锁，正在等待的线程才能恢复运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>今天我们学习了J.U.C中重要的可重入锁，它提供了更高的灵活性，可一定程度避免死锁，同时还有它的好搭档<code>Condition</code>。可以在很多软件中看见它的使用，下次我们将从源码层面分析其实现。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-synchronized</title>
      <link href="/2019/04/11/bing-fa-bian-cheng-synchronized/"/>
      <url>/2019/04/11/bing-fa-bian-cheng-synchronized/</url>
      
        <content type="html"><![CDATA[<p>今天我们来看看并发编程的内置锁：synchronized</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>synchronized</code>是一种使用简单的锁关键字，简单来说用法大致分为三种：</p><ul><li>指定加锁对象：给给定对象加锁，进入同步代码前要获得给定对象的锁。</li><li>直接作用于方法实例：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。</li><li>直接作用于静态方法：相当于对当前类进行加锁，进入同步代码前要获得当前类的锁。</li></ul><h4 id="指定加锁对象"><a href="#指定加锁对象" class="headerlink" title="指定加锁对象"></a>指定加锁对象</h4><p>先看一个不安全的示例：</p><pre><code class="java">static int j = 0;public static void main(String[] args) throws InterruptedException {    Task first = new Task();    Task second = new Task();    first.start();    second.start();    second.join();    System.out.println(j);}public static class Task extends Thread {    @Override    public void run() {        for (int i = 0; i &lt; 1000; i++) {            j++;        }    }}</code></pre><p>这段代码按理来说，第二个线程执行完毕后总之应该为2000，但实际上因为并发修改的原因，值总是&lt;=2000。这个时候使用最简单的<code>synchronized</code>来对一个共享对象加锁，即可轻松的解决，如下示。</p><pre><code class="java">static Object monitor = new Object();public void run() {    synchronized (monitor) { //线程必须获得monitor对象的锁才可以继续执行        for (int i = 0; i &lt; 1000; i++) {            j++;        }    }}</code></pre><h4 id="直接作用于实例方法"><a href="#直接作用于实例方法" class="headerlink" title="直接作用于实例方法"></a>直接作用于实例方法</h4><p>还是先看一个例子：</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {        Student student = new Student();        Task first = new Task(student);        Task second = new Task(student);        first.start();        second.start();        first.join();        second.join();    }    public static class Student {        private void say() {            System.out.println(&quot;你好啊&quot;);            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    public static class Task extends Thread {        private Student student;        public Task(Student student) {            this.student = student;        }        @Override        public void run() {            student.say();        }    }</code></pre><p>上面的程序执行效果是：同时输出你好啊，1秒后程序结束。这代表两个线程是并发执行的，怎么改成串行的呢？很简单，只需要在<code>say()</code>修饰<code>synchronized</code>即可。</p><pre><code class="java">private synchronized void say() {    System.out.println(&quot;你好啊&quot;);    try {        TimeUnit.SECONDS.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p>这样程序执行效果为你好啊，一秒过后再次输出你好啊，再过一秒程序结束。这里需要注意的是，因为调用<code>say()</code>的对象是同一个<code>student</code>，所以锁才会生效。</p><p>正好我们复习一下第一种加锁方式（指定加锁对象）也是可以的：</p><pre><code class="java">private void say() {    synchronized (this) {        System.out.println(&quot;你好啊&quot;);        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>这种写法的优势是可以有效的缩小临界区的范围，以后我们讲到锁的优化时会进行学习。</p><h4 id="直接作用于静态方法"><a href="#直接作用于静态方法" class="headerlink" title="直接作用于静态方法"></a>直接作用于静态方法</h4><p>还是以上面的例子为参考，可以看出上面加锁的都是同一个对象，如果换成2个不同的<code>student</code>对象呢？答案是不可以。</p><pre><code class="java">Student student = new Student();Student student2 = new Student();Task first = new Task(student);   //synchronized锁的是调用方法的实例即studentTask second = new Task(student2); //synchronized锁的是调用方法的实例即student2first.start();second.start();first.join();second.join();private synchronized void say() {    System.out.println(&quot;你好啊&quot;);    try {        TimeUnit.SECONDS.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><p>如何改动可以生效呢？将<code>say()</code>改为静态方法，这样锁的就是类了。</p><pre><code class="java">private static synchronized void say() {    System.out.println(&quot;你好啊&quot;);    try {        TimeUnit.SECONDS.sleep(1);    } catch (InterruptedException e) {        e.printStackTrace();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Java中，最基本的互斥同步手段就是<code>synchronized</code>关键字，<code>synchronized</code>关键字编译后，会在同步块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，这两个字节码都需要一个<code>Reference</code>类型的参数来指明要锁定和解锁的对象。如果<code>synchronized</code>指定了加锁对象，那就是这个对象；如果没有则判断是作用于实例方法还是类方法(被static修饰)，去取对应的对象或者Class对象来作为<code>Reference</code>。</p><p>按照虚拟机规范，当执行<code>monitorenter</code>，先去获取对象的锁，如果这个对象没被锁定或者当前线程已经拥有这个对象的锁，那么锁计数+1；同样，<code>monitorexit</code>就是-1。当为0时锁就释放了。如果遇到了获取锁失败的情况，那么则等待，直到锁被别的线程释放。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-无锁CAS之原子变量</title>
      <link href="/2019/04/08/bing-fa-bian-cheng-wu-suo-cas-zhi-yuan-zi-bian-liang/"/>
      <url>/2019/04/08/bing-fa-bian-cheng-wu-suo-cas-zhi-yuan-zi-bian-liang/</url>
      
        <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>无锁CAS（Compare and swap，比较和交换）是一种乐观的并发控制策略，它假设对资源的访问是没有冲突的，遇到冲突进行重试操作直到没有冲突为止。这种设计思路和数据库的乐观锁很相像。在硬件层面，大部分的处理器都支持原子化的CAS指令。也就是说比较和交换这个操作是有处理器来保证是原子操作的（在最坏的情况下，如果处理器不支持，JVM将使用自旋锁）。</p><p>简单来说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在是什么样子的。如果不是你想象的那样，则说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。</p><p>优势：无锁更优的性能，没有死锁风险。</p><blockquote><p>虽然Java语言锁定语法比较简洁，但JVM和操作在管理锁时需要完成的工作却并不简单。在实现锁定是需要遍历JVM一条非常复杂的代码路径，并可能导致操作系统的锁定、线程挂起和上下文切换等操作。在最好的情况下，在锁定时至少需要一次CAS，因此<br>虽然在使用锁时没有用到CAS，但实际上也无法节约任何执行开销。另一方面，在程序执行内部执行CAS时不需要执行JVM代码、系统调用或者线程调度操作。在应用级上看起来越长的代码路径，如果加上JVM和操作系统的代码调用，那么事实上却变得更短。<br>CAS主要的缺点是，它将使调用者处理竞争问题（重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞）。</p></blockquote><p>缺点：它将使调用者处理竞争问题（重试、回退、放弃），而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞）。</p><h3 id="JDK中的原子操作类"><a href="#JDK中的原子操作类" class="headerlink" title="JDK中的原子操作类"></a>JDK中的原子操作类</h3><p>在JDK8中<code>java.util.concurrent.atomic</code>中展示了12个以<code>Atomic</code>开头的原子变量类，这些类比锁的粒度更细，量级更轻。原子变量相当于一种泛化的volatile，它支持原子的和有条件的 读改写 操作。</p><pre><code>AtomicBooleanAtomicIntegerAtomicIntegerArrayAtomicIntegerFieldUpdaterAtomicLongAtomicLongArrayAtomicLongFieldUpdaterAtomicMarkableReferenceAtomicReferenceAtomicReferenceArrayAtomicReferenceFieldUpdaterAtomicStampedReferenceDoubleAccumulatorDoubleAdderLongAccumulatorLongAdderStriped64</code></pre><p>这12个原子变量类可分为4组：</p><ol><li>标量类</li><li>更新器类</li><li>数组类</li><li>复合变量类</li></ol><p>最常用的原子变量就是标量类：如<code>AtomicInteger</code>、<code>AtomicBoolean</code>、<code>AtomicLong</code>、<code>AtomicReference</code>。</p><p>这里举几个常用的类为例子，其他原子类操作也都是类似的。</p><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><pre><code class="java">static int threadCount = 20;static AtomicInteger count = new AtomicInteger();static CountDownLatch lacth = new CountDownLatch(threadCount);public static void main(String[] args) throws InterruptedException {    for (int i = 0; i &lt; threadCount; i++) {        new Thread(() -&gt; {            for (int j = 0; j &lt; 10000; j++) {                count.incrementAndGet();            }            lacth.countDown();        }).start();    }    lacth.await();    System.out.println(count.get());}</code></pre><p>console output:</p><pre><code>200000</code></pre><p>看一下具体的实现：</p><pre><code class="java">// setup to use Unsafe.compareAndSwapInt for updatesprivate static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;   //保存着value字段在当前对象中的偏移量（其实就是一个字段到对象头部的偏移量，通过这个偏移量可以快速定位字段）static {    try {        valueOffset = unsafe.objectFieldOffset            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));    } catch (Exception ex) { throw new Error(ex); }}private volatile int value; </code></pre><p><code>Unsafe</code>类封装了指针操作，JDK中不能直接使用这个类。其中<code>openJDK</code>中<code>Unsafe</code>的实现可以参考<a href="https://github.com/library-of-reading/OpenJDK/blob/master/jdk/src/share/classes/sun/misc/Unsafe.java" target="_blank" rel="noopener">Unsafe</a></p><p>接下来我们来模拟一下实现：</p><pre><code class="java">/** * 模拟CAS操作 *  */public class SimulatedCAS {    protected int value;    public SimulatedCAS(int initialValue) { // Unsafe中通过offset定位字段，并且去内存中修改这个值，我们这里为方便起见直接使用初始化值        this.value = initialValue;    }    public synchronized int get() {        return value;    }    // 当期望值==旧值时成功    public synchronized boolean compareAndSet(int expectedValue, int newValue) {        return (expectedValue == compareAndSwap(expectedValue, newValue));    }    public synchronized int compareAndSwap(int expectedValue, int newValue) {        int oldValue = value;        if (oldValue == expectedValue) {            value = newValue;        }        System.out.println(&quot;oldValue=&quot; + oldValue + &quot;, expectedValue=&quot; + expectedValue + &quot;, newValue=&quot; + newValue);        return oldValue;    }}</code></pre><pre><code class="java">/** * 模拟AtomicInteger */public class SimulatedAtomicInteger extends SimulatedCAS {    public SimulatedAtomicInteger(int initialValue) {        super(initialValue);    }   // 自旋    public int incrementAndGet() {        for (;;) {            int current = value;            int next = current + 1;            System.out.println(&quot;current=&quot; + current + &quot;, next=&quot; + next);            if (compareAndSet(current, next)) {                return next;            }        }    }}</code></pre><p>使用相同的测试代码，发现计数器能正常使用。</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p><code>AtomicReference</code>和<code>AtomicInteger</code>非常相似，不过是对对象的引用进行封装。直接看代码：</p><pre><code class="java">static AtomicReference&lt;User&gt; ar = new AtomicReference&lt;&gt;();User oldUser = new User(&quot;pleuvoir&quot;, 18); //要修改的对象实例ar.set(oldUser);System.out.println(&quot;oldUser=&quot; + oldUser + &quot;, ar=&quot; + ar.get());oldUser.setAge(14); //这一步修改了对象属性，会发现原子引用中get的也变了System.out.println(&quot;oldUser=&quot; + oldUser + &quot;, ar=&quot; + ar.get());User newUser = new User(&quot;duke&quot;, 27); boolean flag = ar.compareAndSet(oldUser, newUser); //交换成功后只有newUser的修改才会改变原子引用System.out.println(&quot;更新成功？&quot; + flag + &quot;, oldUser=&quot; + oldUser + &quot;, ar=&quot; + ar.get());oldUser.setName(&quot;pleuvoir~&quot;);System.out.println(&quot;oldUser=&quot; + oldUser + &quot;, newUser=&quot; + newUser + &quot;, ar=&quot; + ar.get());newUser.setName(&quot;duke~&quot;);System.out.println(&quot;oldUser=&quot; + oldUser + &quot;, newUser=&quot; + newUser + &quot;, ar=&quot; + ar.get());</code></pre><p>console output：</p><pre><code>oldUser=User [name=pleuvoir, age=18], ar=User [name=pleuvoir, age=18]oldUser=User [name=pleuvoir, age=14], ar=User [name=pleuvoir, age=14]更新成功？true, oldUser=User [name=pleuvoir, age=14], ar=User [name=duke, age=27]oldUser=User [name=pleuvoir~, age=14], newUser=User [name=duke, age=27], ar=User [name=duke, age=27]oldUser=User [name=pleuvoir~, age=14], newUser=User [name=duke~, age=27], ar=User [name=duke~, age=27]</code></pre><p>可以看出<code>AtomicReference</code>中保存是对象本身的引用，当对象本身发生变化后<code>get()</code>所得也会变化。使用<code>compareAndSet(expected, update)</code>交换后，原来的<code>expected</code>对象将失效，和<code>AtomicReference</code>脱离关系，之后对<code>expected</code>对象的操作将不再影响<code>AtomicReference</code>所得。</p><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>假设<code>expected = A , update = C</code>，那么当我们执行CAS时，如果有另外一几个线程将A改为了B，紧接着又改回了A，那么对于此次CAS操作而言也是成功的。对于某些场景而言，这种异常出现是无关紧要的，因为我们只关心最终结果。如果不仅需要关注结果而且还想关注过程，JDK为我们提供了2个类来解决ABA问题。它们分别是<code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>。个人推荐使用<code>AtomicStampedReference</code>，类似于数据库乐观锁。</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><pre><code class="java">static AtomicStampedReference&lt;String&gt; asr = new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);public static void main(String[] args) throws InterruptedException {    int oldStamp = asr.getStamp();    String oldReference = asr.getReference();    System.out.println(&quot;版本号=&quot; + oldReference + &quot;，当前变量值=&quot; + oldStamp);    Thread rightThread = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot;当前变量值=&quot; + oldReference + &quot;当前版本戳=&quot; + oldStamp                    + &quot;更新成功？&quot; + asr.compareAndSet(oldReference, &quot;B&quot;, oldStamp, oldStamp + 1));        }    });    rightThread.start();    rightThread.join(); // 等正确的执行完    Thread errorThread = new Thread(new Runnable() {        @Override        public void run() {            int stamp = asr.getStamp();            String reference = asr.getReference();            System.out.println(Thread.currentThread().getName() + &quot;当前变量值=&quot; + reference + &quot;当前版本戳=&quot;                    + stamp + &quot;更新成功？&quot; + asr.compareAndSet(oldReference, &quot;B&quot;, oldStamp, oldStamp + 1));            // 这是正确的使用方式，上面的只是为了模拟失败才使用了一开始定义的旧的oldStamp            System.out.println(Thread.currentThread().getName() + &quot;当前变量值=&quot; + reference + &quot;当前版本戳=&quot;                    + stamp + &quot;更新成功？&quot;                    + asr.compareAndSet(reference, &quot;B&quot;, stamp, stamp + 1));        }    });    errorThread.start();    errorThread.join();}</code></pre><p>console output:</p><pre><code>版本号=A，当前变量值=0Thread-0当前变量值=A当前版本戳=0更新成功？trueThread-1当前变量值=B当前版本戳=1更新成功？falseThread-1当前变量值=B当前版本戳=1更新成功？false</code></pre><p>上面的例子演示了<code>AtomicStampedReference</code>在版本号不正确时可以正常工作。实际在并发程序中，<strong>更新时记得从原子引用中拿最新的版本戳和数据即可</strong>。</p><h4 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h4><pre><code class="java">static AtomicMarkableReference&lt;String&gt; amr = new AtomicMarkableReference&lt;String&gt;(&quot;A&quot;, false);public static void main(String[] args) throws InterruptedException {    String oldReference = amr.getReference();    Thread rightThread = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot;当前变量值=&quot; + oldReference + &quot;更新成功？&quot;                    + amr.compareAndSet(oldReference, &quot;B&quot;, false, true));        }    });    Thread errorThread = new Thread(new Runnable() {        @Override        public void run() {            System.out.println(Thread.currentThread().getName() + &quot;当前变量值=&quot; + oldReference + &quot;更新成功？&quot;                    + amr.compareAndSet(oldReference, &quot;B&quot;, false, true));        }    });    rightThread.start();    rightThread.join();    errorThread.start();    errorThread.join();}</code></pre><p>这是<code>AtomicStampedReference</code>的用法，个人觉得很鸡肋，不如直接使用带版本戳的<code>AtomicStampedReference</code>，其中<code>V get(boolean[] markHolder)</code>也不是很好用。</p><h3 id="性能比较：锁与原子变量"><a href="#性能比较：锁与原子变量" class="headerlink" title="性能比较：锁与原子变量"></a>性能比较：锁与原子变量</h3><p>如果基于锁和原子变量来实现一个计数器，那么哪个性能更优？</p><p>测试表明：当高度竞争的情况下，锁的性能&gt;原子变量；在更真实的竞争情况下，原子变量&gt;锁的性能。如果追求更高的性能，可以尝试使用<code>ThreadLocal</code>。如果以后有机会的话，会做专门的测试。</p><p>-end</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-线程的并发工具</title>
      <link href="/2019/04/07/bing-fa-bian-cheng-xian-cheng-de-bing-fa-gong-ju/"/>
      <url>/2019/04/07/bing-fa-bian-cheng-xian-cheng-de-bing-fa-gong-ju/</url>
      
        <content type="html"><![CDATA[<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>是一组线程等待其他的线程完成工作以后在执行；await用来等待，countDown负责计数器的减一；可以多次使用等待方法，将在扣减完毕后一起释放。简单来说就是增强版的join；CountDownLatch使用时将引用传入需要控制的线程即可。</p><p>作用：一个线程等待其他线程完成以后再工作，<strong>可以用于控制线程执行顺序</strong></p><p>注意：计数器必须大于0</p><p>示例：</p><pre><code class="java">static final CountDownLatch LATCH = new CountDownLatch(3);    public static void main(String[] args) throws InterruptedException {        new Worker().start();        for (int i = 0; i &lt; 3; i++) {            new Main(i).start();        }        LATCH.await();  //可以多次使用等待方法，将在扣减完毕后一起释放        System.out.println(System.currentTimeMillis() + &quot; 主线程执行了..&quot;);    }    static class Main extends Thread {        public Main(int i ){            setName(&quot;Main-&quot; + i);        }        @Override        public void run() {            try {                TimeUnit.SECONDS.sleep(ThreadLocalRandom.current().nextLong(5));                System.out.println(getName() + &quot; Main..go&quot;);                LATCH.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    static class Worker extends Thread {        @Override        public void run() {            try {                LATCH.await();                System.out.println(System.currentTimeMillis() + &quot; Worker..go&quot;);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }</code></pre><p>执行结果可能是：</p><pre><code>Main-2 Main..goMain-1 Main..goMain-0 Main..go1554609118643 Worker..go1554609118643 主线程执行了..</code></pre><p>可以看到主线程和Worker线程一直在等待3个Main线程执行完毕。当<code>LATCH.countDown()</code>扣减3次完毕时<code>LATCH.await()</code>返回，程序继续执行。</p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>让一组线程达到某个屏障，被阻塞，一直到组内最后一个线程达到屏障时，屏障开放，所有被阻塞的线程会继续运行。</p><p>作用：1.测试并发；2.可以其他线程执行完成后在执行自定义的任务。</p><pre><code class="java">CyclicBarrier(int parties) CyclicBarrier(int parties, Runnable barrierAction)，屏障开放，barrierAction定义的任务会执行。</code></pre><p>某个线程调用<code>CyclicBarrier.await()</code>代表我已经到达屏障，然后当前线程被阻塞。如果当前线程是最后一个到达屏障点的，那么所有等待的线程被激活。</p><p>CountDownLatch和CyclicBarrier区别：</p><ol><li><p>countdownlatch放行由外部线程控制，CyclicBarrier放行由一组线程本身控制 </p></li><li><p>countdownlatch放行条件&gt;=线程数，CyclicBarrier放行条件==线程数</p></li></ol><p>示例：</p><pre><code class="java">static final CyclicBarrier BARRIER = new CyclicBarrier(3);    static final CyclicBarrier BARRIER_WITH_TASK = new CyclicBarrier(2, new Runnable() {        @Override        public void run() {            System.out.println(&quot;barrier_with_task GO..&quot;);        }    });    public static void main(String[] args) throws InterruptedException, BrokenBarrierException {        // 普通用法可循环使用，注意不要再不同线程中用        for (int i = 0; i &lt; 3; i++) {            new ExcuteThread(&quot;normal-&quot; + i).start();        }        // 到达屏障前会执行BARRIER_WITH_TASK定义的内容        for (int i = 0; i &lt; 2; i++) {            new ExcuteThread_2().start();        }    }    static class ExcuteThread extends Thread {        public ExcuteThread(String name) {            super(name);        }        @Override        public void run() {            try {                if (new Random().nextBoolean()) {                    TimeUnit.SECONDS.sleep(2);                }                System.out.println(getName() + &quot; 到达屏障前&quot;);                BARRIER.await();  //第一次使用                TimeUnit.SECONDS.sleep(3);                System.out.println(getName() + &quot; over&quot;);                BARRIER.await(); //可以再次使用，所以称为循环屏障                TimeUnit.SECONDS.sleep(3);                System.out.println(getName() + &quot; over again&quot;);            } catch (InterruptedException | BrokenBarrierException e) { //BrokenBarrierException代表已经破损，可能无法等待所有线程齐全了                e.printStackTrace();            }        }    }    static class ExcuteThread_2 extends Thread {        @Override        public void run() {            try {                if (new Random().nextBoolean()) {                    TimeUnit.SECONDS.sleep(2);                }                System.out.println(getName() + &quot; 到达屏障前&quot;);                BARRIER_WITH_TASK.await();                TimeUnit.SECONDS.sleep(3);                System.out.println(getName() + &quot; 到达位置&quot;);            } catch (InterruptedException | BrokenBarrierException e) {                e.printStackTrace();            }        }    }</code></pre><p>以上示例想演示什么？3个ExcuteThread线程会随机休眠，只有等待最后一个线程休眠结束后才会执行<code>CyclicBarrier.await()</code>后的方法，当执行完毕后我们再次调用<code>CyclicBarrier.await()</code>会发现它依然生效，这也正是称为循环屏障的原因。</p><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><p>作用：流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p><p>示例：</p><pre><code class="java">final Semaphore SA = new Semaphore(5);    public static void main(String[] args) {        SemaphoreTest semaphoreTest = new SemaphoreTest();        for (int i = 0; i &lt; 10; i++) {            new Thread(semaphoreTest).start();        }    }    @Override    public void run() {        try {            SA.acquire(); // 获取1个许可，如果不能获取到许可则会一直阻塞            TimeUnit.SECONDS.sleep(3);            System.out.println(System.currentTimeMillis() + Thread.currentThread().getName() + &quot; go.&quot;);            SA.release(); // 归还1个许可        } catch (InterruptedException e) {            e.printStackTrace();        }    }</code></pre><p>console output:</p><pre><code>1554624115958Thread-0 go.1554624115958Thread-4 go.1554624115958Thread-1 go.1554624115958Thread-3 go.1554624115958Thread-2 go.1554624118958Thread-6 go.1554624118958Thread-7 go.1554624118958Thread-9 go.1554624118958Thread-8 go.1554624118958Thread-5 go.</code></pre><p>程序执行的结果是每次有5个线程并行执行，因为只有5个许可，也就是说前5个线程可以获取到许可，其他线程想要获取许可必须等待已获取许可的线程归还许可。</p><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>交换者用于交换两个线程之间的数据。直接看代码：</p><pre><code class="java">public static void main(String[] args) {        Exchanger&lt;String&gt; exchange = new Exchanger&lt;String&gt;();        new Thread(new Runnable() {            @Override            public void run() {                String salary = &quot;1&quot;;                try {                    System.out.println(&quot;我的工资是&quot; + salary + &quot;，你呢？&quot; + exchange.exchange(salary)); //会一直等待第二个线程也执行exchange方法                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                String salary = &quot;2&quot;;                try {                    System.out.println(&quot;我的工资是&quot; + salary + &quot;，你呢？&quot; + exchange.exchange(salary));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }).start();    }</code></pre><p>console output:</p><pre><code class="java">我的工资是2，你呢？1我的工资是1，你呢？2</code></pre><p>这个类基本没什么可说的，如果担心交换的时间过久，可以使用带超时时间的方法。</p><h4 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h4><p>强悍的线程阻塞工具类（并且是静态的），它可以在线程的任意位置让线程阻塞。与<code>Thread.suspend()</code>相比，它弥补了容易导致死锁的缺点。与<code>Object.wait()</code>相比，它不需要获取对象的锁。</p><p>示例：</p><pre><code class="java">public static void main(String[] args) throws InterruptedException {        ChangeObjectThread t1 = new ChangeObjectThread(&quot;t1&quot;);        ChangeObjectThread t2 = new ChangeObjectThread(&quot;t2&quot;);        t1.start();        TimeUnit.SECONDS.sleep(1); // 保证t1.park在t1.unpark前执行        t2.start();        if (ThreadLocalRandom.current().nextBoolean()) {            t1.interrupt();        } else {            LockSupport.unpark(t1);            System.out.println(&quot;t1&quot; + &quot;|&quot; + System.currentTimeMillis() + &quot; unpark&quot;);        }        LockSupport.unpark(t2);        System.out.println(&quot;t2&quot; + &quot;|&quot; + System.currentTimeMillis() + &quot; unpark&quot;);        t1.join();        t2.join();    }    public static class ChangeObjectThread extends Thread {        public ChangeObjectThread(String name) {            super(name);        }        @Override        public void run() {            try {                TimeUnit.MILLISECONDS.sleep(ThreadLocalRandom.current().nextLong(150));            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(getName() + &quot;|&quot; + System.currentTimeMillis() + &quot; park&quot;);            // LockSupport.park();// 阻塞 如果被中断，不会抛出异常而是修改中断标志位            LockSupport.park(this); //建议使用方便dump查看等待对象            System.out.println(isInterrupted());            if (Thread.interrupted()) {                System.out.println(&quot;被中断了&quot;);                System.out.println(isInterrupted());            }        }    }</code></pre><p>console output:</p><pre><code>t1|1554627431151 parkfalset1|1554627432066 unparkt2|1554627432066 unparkt2|1554627432202 parkfalse</code></pre><p>或者</p><pre><code class="java">t1|1554627498633 parktrue被中断了falset2|1554627499600 unparkt2|1554627499654 parkfalse</code></pre><p>可以看到<code>t2.unpark()</code>是在<code>t2.park()</code>之前执行的，但是程序也正常结束了。这里面的实现原理是，LockSupport为每个线程准备了一个许可（只有一个），当许可不可用时会阻塞，当许可可用时<code>park()</code>会立即返回，而<code>unpark()</code>方法则是使许可可用。也就是说<code>t2.unpark()</code>执行后，当执行<code>t2.park()</code>时并不会阻塞了。</p><p>其他的定时阻塞方法：</p><pre><code>LockSupport.parkNanos(nanos);LockSupport.parkUntil(deadline);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-简简单单写一个数据库连接池</title>
      <link href="/2019/03/29/bing-fa-bian-cheng-jian-jian-dan-dan-xie-yi-ge-shu-ju-ku-lian-jie-chi/"/>
      <url>/2019/03/29/bing-fa-bian-cheng-jian-jian-dan-dan-xie-yi-ge-shu-ju-ku-lian-jie-chi/</url>
      
        <content type="html"><![CDATA[<p>本文旨在通过多线程等待通知模式实现一个简单的数据库连接池模型，方便理解连接池的实现原理。</p><p>一般的连接池获取数据库连接一般都带有超时机制，所以实现时可以使用多线程等待通知标准范式。如下示例：</p><pre><code class="java">long overtime = System.currentTimeMillis() + timeout;  //超时的那一刻long remain = timeout; //还能等待多久while (pool.isEmpty() &amp;&amp; remain &gt; 0) { // 当连接池为空并且未超过超时时间时一直等待    pool.wait(remain);    remain = overtime - System.currentTimeMillis(); //重置超时时间}</code></pre><p>我们可以将连接存放在<code>LinkedList</code>中，归还连接往尾部放，获取连接从头部移除。利用等待超时机制，当某线程归还连接时通知正在等待的其他线程，尝试去获取连接。</p><p>核心实现如下：</p><pre><code class="java">private LinkedList&lt;Connection&gt; pool;    // 连接池大小    public DatasourcePool(int capacity) {        // 初始化一定大小的连接到容器中        if (capacity &gt; 0) {            pool = new LinkedList&lt;&gt;();            for (int i = 0; i &lt; capacity; i++) {                pool.addLast(SQLConnectionImpl.fetchOneConnection());            }        }    }    /**     * 获取连接，超时后返回null     */    public Connection get(long timeout) throws InterruptedException {        synchronized (pool) {            // 永不超时            if (timeout &lt; 0) {                while (pool.isEmpty()) { // 当连接池为空时一直等待                    pool.wait();                }                return pool.removeFirst(); // 当其他线程释放连接时获取连接            } else {                long overtime = System.currentTimeMillis() + timeout;  //超时的那一刻                long remain = timeout; //还能等待多久                while (pool.isEmpty() &amp;&amp; remain &gt; 0) { // 当连接池为空并且未超过超时时间时一直等待                    pool.wait(remain);                    remain = overtime - System.currentTimeMillis(); //重置超时时间                }                // 过了超时时间池中有则返回，否则返回null                Connection result = null;                if (!pool.isEmpty()) {                    result = pool.removeFirst();                }                return result;            }        }    }    /**     * 归还数据库连接     */    public void release(Connection connection) {        if (connection != null) {            synchronized (pool) {                pool.addLast(connection);                pool.notifyAll();            }        }    }</code></pre><p>处理业务的线程：</p><pre><code class="java">    @Override    public void run() {        while (count &gt; 0) {            try {                Connection connection = pool.get(1000); //1秒超时                if (connection == null) {                    fail.incrementAndGet();                    System.out.println(Thread.currentThread().getName() + &quot;获取连接失败。&quot;);                } else {                    // 模拟业务操作                    try {                        connection.createStatement();                        connection.commit();                    } catch (SQLException e) {                    } finally { //归还连接                        pool.release(connection);                        success.incrementAndGet();                    }                    System.out.println(Thread.currentThread().getName() + &quot;获取到连接。&quot;);                }            } catch (InterruptedException e) {                e.printStackTrace();                Thread.currentThread().interrupt();            } finally {                this.count--;            }        }        latch.countDown();    }</code></pre><p>测试类：</p><pre><code class="java">DatasourcePool pool = new DatasourcePool(5);AtomicLong success = new AtomicLong(0);AtomicLong fail = new AtomicLong(0);// 50个线程每个线程拿20次连接，总共拿1000次连接int threadCount = 50;int connectionCount = 20;CountDownLatch latch = new CountDownLatch(threadCount);for (int i = 0; i &lt; threadCount; i++) {    new Thread(new Worker(pool, success, fail, connectionCount, latch), &quot;Worker-&quot; + i).start();}latch.await();System.out.println(&quot;共获取连接&quot; + threadCount * connectionCount + &quot;次&quot;);System.out.println(&quot;成功获取连接&quot; + success.get() + &quot;次&quot;);System.out.println(&quot;失败获取连接&quot; + fail.get() + &quot;次&quot;);</code></pre><p>以上使用的是线程最基本的等待超时机制，JUC为我们提供了更高级友好的工具类<code>Semaphore</code>。参照如下的实现：</p><pre><code class="java">    private Semaphore unuse, used;  // unuse 表示可用的数据库连接，used表示已用的数据库连接   unuse+used=capacity    /**     * 获取连接，超时后返回null     */    public Connection get(long timeout) throws InterruptedException {        Connection conn = null;        if (unuse.tryAcquire(timeout, TimeUnit.MILLISECONDS)) {            // 可用的-1            synchronized (pool) {                conn = pool.removeFirst();            }            used.release(); // 不可用的+1        }        return conn;    }    /**     * 归还数据库连接     * @throws InterruptedException      */    public void release(Connection connection) throws InterruptedException {        if (connection != null) {            //不可用的-1            used.acquire();            synchronized (pool) {                pool.addLast(connection);            }            //可用的+1            unuse.release();        }    }</code></pre><p>这里实现比较难理解的是为什么有2个Semaphore？原因是因为数据库连接是个资源，空位本身也是个资源（空位本身也有申请和释放的一些动作）。方便我们统计和计算有多少连接被占用，又有多少空闲。当然我们使用一个Semaphore也是可以实现连接池的功能的。</p><p>-End</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-基础拾遗</title>
      <link href="/2019/03/29/bing-fa-bian-cheng-ji-chu-shi-yi/"/>
      <url>/2019/03/29/bing-fa-bian-cheng-ji-chu-shi-yi/</url>
      
        <content type="html"><![CDATA[<p>本文是对并发编程基础知识总结，不包含高级用法，旨在巩固基础，增强对知识点的记忆。所以可以看做是一个手稿，适合熟悉基本概念的同学阅读。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="1）CPU核心数和线程数的关系"><a href="#1）CPU核心数和线程数的关系" class="headerlink" title="1）CPU核心数和线程数的关系"></a>1）CPU核心数和线程数的关系</h4><p>核心数：线程数=1:1 ;使用了超线程技术后=1:2</p><h4 id="2）CPU时间片轮转机制"><a href="#2）CPU时间片轮转机制" class="headerlink" title="2）CPU时间片轮转机制"></a>2）CPU时间片轮转机制</h4><p>又称RR调度，会导致上下文切换</p><h4 id="3）什么是进程和线程？"><a href="#3）什么是进程和线程？" class="headerlink" title="3）什么是进程和线程？"></a>3）什么是进程和线程？</h4><p>进程：程序运行资源分配的最小单位，进程内部有多个线程，会共享这个进程的资源 </p><p>线程：CPU调度的最小单位，必须依赖进程而存在。 </p><h4 id="4）为什么使用并发编程？"><a href="#4）为什么使用并发编程？" class="headerlink" title="4）为什么使用并发编程？"></a>4）为什么使用并发编程？</h4><p>好处：充分利用cpu的资源、加快用户响应的时间，程序模块化，异步化 </p><p>问题：线程共享资源，存在冲突；容易导致死锁；启用太多的线程，有搞垮机器的可能</p><h3 id="你必须知道的几个概念"><a href="#你必须知道的几个概念" class="headerlink" title="你必须知道的几个概念"></a>你必须知道的几个概念</h3><h4 id="1）同步和异步？"><a href="#1）同步和异步？" class="headerlink" title="1）同步和异步？"></a>1）同步和异步？</h4><p>同步方法一旦调用开始，调用者必须等到方法返回后才可以继续后续的行为。</p><p>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者可以立刻继续后续的操作。而异步方法通常会在另外一个线程中执行。</p><h4 id="2）并发和并行？"><a href="#2）并发和并行？" class="headerlink" title="2）并发和并行？"></a>2）并发和并行？</h4><p>严格来说：并行的多个任务是真的在同时执行，真正的并行只可能出现在多个CPU的系统中（如多核CPU）。</p><p>对于并发而言，多个任务是在交替执行，系统不断的在任务之间切换，但对外部观察者而言看起来是在并行。另外，并发更关注在单位时间内可以处理事情的能力 。</p><h4 id="3）临界区？"><a href="#3）临界区？" class="headerlink" title="3）临界区？"></a>3）临界区？</h4><p>临界区用来表示一种公共资源或者共享数据，可以被多个线程使用，但是每一次都只能有一个线程使用它。一旦临界区资源被占用，其他线程只能等待。在并行程序中，临界区资源是保护的对象，如果保护不得当，出现的结果可能都不是线程需要的。</p><h4 id="4）阻塞和非阻塞？"><a href="#4）阻塞和非阻塞？" class="headerlink" title="4）阻塞和非阻塞？"></a>4）阻塞和非阻塞？</h4><p>阻塞和非阻塞通常用来形容多线程的相互影响，比如一个线程占用了临界区资源，那么其他需要这个资源的线程都必须在临界区等待，即出现线程挂起现象，这种情况就是阻塞。如果占用资源的线程一直不释放资源，其他阻塞在临界区的线程会一直等待。</p><p>非阻塞意思与之相反。</p><h4 id="5）死锁、活锁、饥饿？"><a href="#5）死锁、活锁、饥饿？" class="headerlink" title="5）死锁、活锁、饥饿？"></a>5）死锁、活锁、饥饿？</h4><p>死锁恐怕是并发编程中最糟糕的情况了，通常是因为两个线程互相占用对方需要的资源，而都不进行释放，导致彼此之间相互等待对方释放资源，产生了无限期等待的情况，如果没有外力介入，这种等待将一直存在。</p><p><strong>Tips：</strong>如果想避免死锁，可以使用无锁函数，还可使用可重入锁，通过重入锁的中断或者限时等待都可以有效规避死锁的问题。</p><p>活锁：线程之间互相谦让，为对方让出资源（两个人一起用电梯，一个人想进来，一个人想出去，不停的为对方让位置）。出现这种情况，资源不停的在线程间跳动，导致没有一个线程可以同时拿到所有资源正常执行，这种情况就是活锁。</p><p>饥饿：可能是因为线程优先级低或者关键的资源一直被占用，导致自己一直得不到执行。饥饿现象没有死锁那么严重，可能在未来一段时间内解决。</p><h4 id="6）并发级别"><a href="#6）并发级别" class="headerlink" title="6）并发级别"></a>6）并发级别</h4><ul><li><p>阻塞</p><p>（synchronized）</p></li><li><p>无饥饿</p><p>（对非公平锁允许高优先级线程插队，低优先会饥饿）</p></li><li><p>无障碍</p><p>（多个线程同时进入临界区，进行修改，如果出现问题则回滚重试；一种可行的实现是依赖一致性标记，操作之前读取保存这个标记，操作完成后检查标记是否被更改过。如果不一致则重试）</p></li><li><p>无锁</p><p>（要求：一个线程可以在有限步内完成操作。无限循环CAS，由于重试次数过多某些运气差的线程会出现饥饿现象）</p></li><li><p>无等待</p><p>（要求：所有线程可以在有限步内完成操作。一种典型的实现就是RCU[Read Copy Update]，基本思想是对数据的读不加控制。但是在写数据时，先取得原始数据的副本，接着修改副本数据，这也是为什么读可以不加控制的原因，修改完成在合适的时机写回数据）</p></li></ul><h3 id="认识Java里的线程"><a href="#认识Java里的线程" class="headerlink" title="认识Java里的线程"></a>认识Java里的线程</h3><h4 id="1）线程的状态？"><a href="#1）线程的状态？" class="headerlink" title="1）线程的状态？"></a>1）线程的状态？</h4><p>有五种：新建、就绪、阻塞、运行、死亡</p><p>当调用<code>wait()、sleep()</code>时进入阻塞状态，在wait状态的线程被<code>notify()或notifyAll()</code>时重新进入就绪态。当阻塞状态的线程被中断时会抛出<code>InterruptedException</code>异常。</p><h4 id="2）启动线程的三种方式？"><a href="#2）启动线程的三种方式？" class="headerlink" title="2）启动线程的三种方式？"></a>2）启动线程的三种方式？</h4><ul><li>实现runnable接口</li><li>继承Thread类</li><li>实现Callable接口（有返回值）</li></ul><h4 id="3）如何让线程安全停止？"><a href="#3）如何让线程安全停止？" class="headerlink" title="3）如何让线程安全停止？"></a>3）如何让线程安全停止？</h4><p>任务执行完成会自然终止或者出现未知异常会停止。</p><ul><li>强制</li></ul><p>JDK提供了一些类强制停止的方法，可以近似理解为结束任务管理器中的进程。但由于这些设计并非良好，所以已不再建议使用：</p><p><code>stop()，resume()，suspend()</code>已不建议使用，stop()会导致线程不会正确释放资源，suspend()容易导致死锁。</p><ul><li>协作式停止</li></ul><p>使用线程的<code>interrupt()</code>方法。调用一个线程的interrupt()方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。</p><p><code>isInterrupted()</code>判定当前线程是否处于中断状态。</p><p>方法里如果抛出InterruptedException，线程的中断标志位会被复位成false，如果确实是需要中断线程，要求我们自己在catch语句块里再次调用interrupt()。</p><p>static方法<code>Thread.interrupted()</code>判定当前线程是否处于中断状态，同时中断标志位改为false，使用时需要特别注意。 </p><p>一个设计良好的响应中断范式：</p><pre><code class="java">public class RunnableTask implements Runnable {    @Override    public void run() {        // 如果线程本身就是需要轮询执行的可以使用这种方式        while (!Thread.currentThread().isInterrupted()) {            System.out.println(&quot;RunnableTask working...&quot;);            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();                Thread.currentThread().interrupt();                // 静态方法，是否中断状态，注意：此方法会重新将标记为 置为 false//                System.out.println(Thread.interrupted());//                Thread.currentThread().interrupt();            }        }        // 如果本身只执行一次，那么在需要终中断的时候判定标志位//        if (!Thread.currentThread().isInterrupted()) {//            System.out.println(&quot;RunnableTask working...&quot;);//            try {//                TimeUnit.SECONDS.sleep(1);//            } catch (InterruptedException e) {//                e.printStackTrace();//                Thread.currentThread().interrupt();//            }//        }    }}</code></pre><h4 id="4）其他概念"><a href="#4）其他概念" class="headerlink" title="4）其他概念"></a>4）其他概念</h4><p><code>run()和start()</code>：run方法就是普通对象的普通方法，只有调用了<code>start()</code>后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。</p><p><code>yield()</code>：高风亮节让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行。</p><p>线程的优先级</p><p>取值为1~10，缺省为5，但线程的优先级不可靠，不建议作为线程开发时候的手段；因为有可能在Windows下操作系统支持，但切换为Linux后则无法正常工作了。</p><p>守护线程</p><p>和主线程共死，finally不能保证一定执行。</p><p><code>join()</code>：一般用于控制线程执行的顺序，可以理解为插队。<code>thread.join();</code>即代表<code>thread</code>线程将在当前线程任务之前执行。实现原理为不停检查join线程是否存活，如果存活则一直等待<code>wait(0)</code>，如果结束则调用<code>notifyAll()。</code>一般用法是将某个线程传递进具体的任务<code>run()</code>中调用<code>join()</code>。<strong>需要注意的是：由于<code>join()</code>机制本身是依靠<code>wait()、notify()</code>实现的，所以使用时应避免直接使用等待通知，避免异常。</strong></p><h4 id="5）线程间的共享"><a href="#5）线程间的共享" class="headerlink" title="5）线程间的共享"></a>5）线程间的共享</h4><p>synchronized内置锁，可以锁对象也可以锁类</p><ul><li><p>对象锁，锁的是类的对象实例。</p></li><li><p>类锁，锁的是每个类的的Class对象，每个类的的Class对象在一个虚拟机中只有一个，所以类锁也只有一个。</p></li></ul><p>synchronized使用时如果锁定的方法是static的，也是类锁。<strong>需要注意的是：在发生异常时会释放当前持有的锁。</strong></p><ul><li>volatile</li></ul><p>适合于只有一个线程写，多个线程读的场景，因为它只能确保可见性。</p><ul><li>ThreadLocal</li></ul><p>线程变量。可以理解为是个map，类型 Map&lt;Thread, Object&gt;</p><h4 id="6）线程间的协作"><a href="#6）线程间的协作" class="headerlink" title="6）线程间的协作"></a>6）线程间的协作</h4><p>使用等待通知机制，这里有一套标准范式：</p><p>等待方：</p><p>1.获取对象的锁；<br>2.循环里判断条件是否满足，不满足调用wait方法<br>3.条件满足执行业务逻辑 </p><p>通知方：</p><p>1.获取对象的锁<br>2.改变条件<br>3.通知所有等待在对象的线程（注意：应当在临界区结束时进行通知，一般是代码块的最后） </p><p>notify和notifyAll应该用谁？应该尽量使用notifyAll，使用notify因为有可能发生信号丢失的的情况，因为它是随机选择一个持有相同锁的线程。</p><h4 id="7）调用yield-、sleep-、wait-、notify-等方法对锁有何影响？"><a href="#7）调用yield-、sleep-、wait-、notify-等方法对锁有何影响？" class="headerlink" title="7）调用yield()、sleep()、wait()、notify()等方法对锁有何影响？"></a>7）调用<code>yield()、sleep()、wait()、notify()</code>等方法对锁有何影响？</h4><p>线程在执行<code>yield()</code>以后，持有的锁是不释放的。</p><p><code>sleep()</code>方法被调用以后，持有的锁是不释放的。</p><p>调动方法之前，必须要持有锁。调用了<code>wait()</code>方法以后，锁就会被释放（由虚拟机自动执行），当<code>wait()</code>方法返回的时候（即收到通知继续执行），线程会重新持有锁。</p><p>调动方法之前，必须要持有锁，调用<code>notify()、notifyAll()</code>方法本身不会释放锁，一般会在退出<code>synchronized</code>区时自动释放。一般会写在退出区大括号的上一行，保证逻辑上的连续性。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql表设计参考</title>
      <link href="/2019/02/20/mysql-biao-she-ji/"/>
      <url>/2019/02/20/mysql-biao-she-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1 命名规范"></a>1 命名规范</h3><h4 id="1-1-数据库、表、字段的命名要遵守可读性原则"><a href="#1-1-数据库、表、字段的命名要遵守可读性原则" class="headerlink" title="1.1 数据库、表、字段的命名要遵守可读性原则"></a>1.1 数据库、表、字段的命名要遵守可读性原则</h4><p>使用大小写来格式化的库对象名字以获得良好的可读性</p><p>例如：使用custAddress而不是custaddress来提高可读性。</p><h4 id="1-2-数据库、表、字段的命名要遵守表意性原则"><a href="#1-2-数据库、表、字段的命名要遵守表意性原则" class="headerlink" title="1.2 数据库、表、字段的命名要遵守表意性原则"></a>1.2 数据库、表、字段的命名要遵守表意性原则</h4><p>对象的名字应该能够描述它所表示的对象</p><p>例如：对于表，表的名称应该能够体现表中存储的数据内容；对于存储过程应该能够体现存储过程的功能。</p><h4 id="1-3-数据库、表、字段的命名要遵守长名原则"><a href="#1-3-数据库、表、字段的命名要遵守长名原则" class="headerlink" title="1.3 数据库、表、字段的命名要遵守长名原则"></a>1.3 数据库、表、字段的命名要遵守长名原则</h4><p>尽可能少使用或者不使用缩写</p><h3 id="2-存储引擎选择"><a href="#2-存储引擎选择" class="headerlink" title="2 存储引擎选择"></a>2 存储引擎选择</h3><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表锁，即使操作一条记录也会锁住整个表   不适合高并发的操作</td><td>行锁,操作时只锁某一行，不对其它行有影响   适合高并发的操作</td></tr><tr><td>缓存</td><td>只缓存索引，不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr></tbody></table><h4 id="2-1-数据类型选择"><a href="#2-1-数据类型选择" class="headerlink" title="2.1 数据类型选择"></a>2.1 数据类型选择</h4><ul><li><p>优先考虑数字类型</p></li><li><p>其次是日期、时间类型</p></li><li><p>最后是字符类型</p></li><li><p>对于相同级别的数据类型，应该优先选择占用空间小的数据类型</p></li></ul><table><thead><tr><th>列类型</th><th>存储空间</th><th>备注</th></tr></thead><tbody><tr><td>FLOAT</td><td>4个字节</td><td>非精确类型</td></tr><tr><td>DOUBLE</td><td>8个字节</td><td>非精确类型</td></tr><tr><td>DECIMAL</td><td>每4个字节存9个数字，小数点占一个字节</td><td>精确类型</td></tr><tr><td>DATETIME</td><td>MYSQL5.5 8个字节，MYSQL5.6 5个字节</td><td></td></tr><tr><td>TIMESTAMP</td><td>4个字节</td><td>和时区相关</td></tr></tbody></table><p>如果是金额相关那么使用DECIMAL</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql架构和存储引擎</title>
      <link href="/2019/02/19/mysql-jia-gou-he-cun-chu-yin-qing/"/>
      <url>/2019/02/19/mysql-jia-gou-he-cun-chu-yin-qing/</url>
      
        <content type="html"><![CDATA[<p>本文是mysql学习的第一章，主要介绍mysql架构和存储引擎。</p><h2 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h2><ul><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ul><p>连接层：可以理解为JDBC层，用于和客户端进行通信，其中还包括连接池等。</p><p>1）当mysql启动，每一个客户端发出连接请求，服务端会新建一个线程进行处理，每一个线程都有自己的内存空间。如果是线程池的话那么是预先分配一个连接。如果存在多写的情况，修改同一块数据会出现同步问题。</p><p>2）其中连接到服务器进行密码等权限验证也是连接层完成的。</p><p>查询设置最大连接：</p><pre><code class="sql">show VARIABLES like &#39;%max_connections%&#39;set GLOBAL max_connections = 200</code></pre><p>服务层：</p><p>其中服务层由以下4部分构成：</p><ol><li>SQL处理层（负责一些sql语句的执行，存储过程，视图等）</li><li>缓存</li><li>解析（解析为msql认识的语句）</li><li>优化（优化一些无谓的操作）</li></ol><p>整体的流程是：</p><p>1)如果是查询语句，则查询缓存是否有相同的结果，无则进行下一步</p><p>2)解析查询语句，用于解析用户提交的sql为mysql自己认识的语句</p><p>3）优化sql语句，譬如<code>select * from user where 1=1</code>则会优化为<code>select * from user</code>，mysql会进行一些分析，从而避免一些不必要的执行语句。</p><p>关于缓存的使用：</p><p>一般情况下我们会选用外部的缓存中间件如redis，memcache，很少会用去mysql自带的缓存。如果需要开启，需要同时打开开关并设置缓存大小才会生效，如下：</p><pre><code class="sql">show variables like &#39;%query_cache_type%&#39;SET GLOBAL query_cache_size = 4000;SET GLOBAL query_cache_size = 134217728;select * from product_info where product_name =&#39;iphone7&#39;</code></pre><p>当开启了缓存后，会发现第一次查询耗时较久，第二次查询几乎是瞬间返回。关于缓存的内容，它有可能会缓存执行计划，索引，也有可能会缓存数据；具体取决于存储引擎。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li>MyISAM</li><li>Innodb</li></ul><pre><code class="sql">--查看你的mysql现在支持什么存储引擎show engines;--查看默认的存储引擎show variables like &#39;%storage_engine%&#39;;</code></pre><p>查看建表语句：</p><pre><code class="sql">show create table 表名</code></pre><p>一般建表语句中会指明表所使用的的存储引擎。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>特性：</p><p>并发性与锁级别-表级锁</p><p>支持全文检索</p><p>支持数据压缩<br>    myisampack -b -f testmysqm.MYI</p><p>如果使用myisam那么插入数据后会在mysql的安装目录下生成三个文件，假设我们的表名为<code>testmysqm</code>，文件名为分别是以下格式：</p><ol><li>testmysqm.frm（和存储引擎无关，保存的是表结构信息）</li><li>testmysqm.MYD（数据信息DATA）</li><li>testmysqm.MYI(索引信息INDEX)</li></ol><p>具体压缩指令如下（请修改为自己机器的实际目录）：</p><pre><code class="sql">.\myisamchk.exe -b -f &quot;C:\ProgramData\MySQL\MySQL Server 5.6\data\mysqldemo\product_info.MYI&quot;</code></pre><p>如果我们压缩后出现了无法插入修改的问题，可以选择恢复：</p><pre><code class="sql">CHECK table 表名REPAIR table 表名</code></pre><p>适用场景：</p><p>非事务型应用（数据仓库、报表、日志数据）</p><p>只读类应用</p><p>空间类如GIS应用（空间函数、坐标，必须选择myisam，只有它提供空间函数）</p><p>缓存：只缓存索引不缓存真实数据</p><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><p>特性：</p><p>ACID事务支持</p><p>Redo Log和Undo Log</p><p>支持行级锁（并发程度更高</p><p>适用场景：</p><p>大多数需要事务的应用</p><p>mysql5.5以后的默认引擎，需要注意的是可以检查表数据使用的表空间类型，建议使用独立的表空间以提高IO效率。</p><pre><code class="sql">show VARIABLES like &#39;innodb_file_per_table&#39;on:独立的表空间 数据文件 表名.ibdoff:系统表空间 所有表的文件都在ibdataX这一个文件中--on offset global innodb_file_per_table=on</code></pre><p>在mysql5.6以前默认为系统表空间，独立表空间的优点不言而喻，多表写数据操作更快，可收缩系统文件</p><pre><code class="sql">OPTIMIZE TABLE product_info2 收缩优化表，可以理解为整理磁盘空间</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper 安装及简明教程</title>
      <link href="/2019/02/18/zookeeper-an-zhuang-ji-jian-ming-jiao-cheng/"/>
      <url>/2019/02/18/zookeeper-an-zhuang-ji-jian-ming-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper-安装"><a href="#Zookeeper-安装" class="headerlink" title="Zookeeper 安装"></a>Zookeeper 安装</h2><p>ZooKeeper的安装模式分为三种，分别为：单机模式（stand-alone）、集群模式和集群伪分布模式。</p><h3 id="windows-安装"><a href="#windows-安装" class="headerlink" title="windows 安装"></a>windows 安装</h3><p>jdk 是必须的。</p><p><a href="https://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="noopener">下载</a> </p><p>完成后解压。</p><p>如解压的后的目录是 <code>D:\01 dev\zookeeper-3.4.13</code> ，建议在 <code>D:\01 dev</code> 新建 data 及 log 文件夹。</p><p>复制 <code>D:\01 dev\zookeeper-3.4.13\conf\zoo_sample.cfg</code> 文件到当前目录下，并改名为 <code>zoo.cfg</code>。</p><p>修改 <code>zoo.cfg</code> 文件，改为如下配置：</p><pre><code>## 快照文件位置dataDir=D:/01 dev/data## 事务日志位置dataLogDir=D:/01 dev/log</code></pre><p>此时安装已经完成了。</p><h3 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h3><pre><code class="shell">## 下载wget mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.13/zookeeper-3.4.13.tar.gz## 解压文件tar -xzvf zookeeper-3.4.13.tar.gzcd zookeeper-3.4.13/confcp zoo_sample.cfg zoo.cfg## 此时配置不配也可以启动./zkServer.sh start</code></pre><p>此时安装已经完成了。</p><h3 id="Linux-集群安装"><a href="#Linux-集群安装" class="headerlink" title="Linux 集群安装"></a>Linux 集群安装</h3><p>1）安装jdk运行jdk环境</p><p><code>上传jdk1.8安装包</code></p><p>2）安装jdk1.8环境变量</p><pre><code>vi /etc/profileexport JAVA_HOME=/usr/local/jdk1.8.0_181export ZOOKEEPER_HOME=/usr/local/zookeeperexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar刷新profile文件source /etc/profile关闭防火墙</code></pre><p>3）下载zookeeper安装包</p><p><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</code></p><p>4）解压Zookeeper安装包</p><p><code>tar -zxvf zookeeper-3.4.10.tar.gz</code></p><p>5）修改Zookeeper文件夹名称</p><p><code>重命名： mv zookeeper-3.4.10 zookeeper</code></p><p>6）修改zoo_sample.cfg文件</p><pre><code>cd /usr/local/zookeeper/confmv zoo_sample.cfg zoo.cfg修改conf: vi zoo.cfg 修改两处（1） dataDir=/usr/local/zookeeper/data（注意同时在zookeeper创建data目录）（2）最后面添加server.0=192.168.212.154:2888:3888server.1=192.168.212.156:2888:3888server.2=192.168.212.157:2888:3888</code></pre><p>7）创建服务器标识</p><pre><code>服务器标识配置：创建文件夹： mkdir data创建文件myid并填写内容为0： vimyid (内容为服务器标识 ： 0)</code></pre><p>8）复制zookeeper</p><pre><code>进行复制zookeeper目录到node1和node2还有/etc/profile文件把node1、 node2中的myid文件里的值修改为1和2路径(vi /usr/local/zookeeper/data/myid)</code></pre><p>9）启动zookeeper</p><pre><code>启动zookeeper：路径： /usr/local/zookeeper/bin执行： zkServer.sh start(注意这里3台机器都要进行启动)状态： zkServer.sh status(在三个节点上检验zk的mode,一个leader和俩个follower)</code></pre><p>此时安装已经完成了。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><pre><code>bin            存放系统脚本conf           存放配置文件contrib        zk附加功能支持dist-maven     maven仓库文件docs           zk文档lib            依赖的第三方库recipes        经典场景样例代码src            zk源码</code></pre><p>其中 bin 和 conf 是非常重要的两个目录，平时也是经常使用的。</p><h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p><img src="https://i.loli.net/2019/02/20/5c6d009de9df4.jpg" alt=""></p><p>其中 <code>zkServer</code> 为启动服务端，默认端口为 2181；<code>zkCli</code> 是客户端命令行工具。</p><h4 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h4><p>conf 目录为配置文件存放的目录，zoo.cfg 为核心的配置文件</p><p><img src="https://i.loli.net/2019/02/20/5c6d00acbabf9.png" alt=""><br><img src="https://i.loli.net/2019/02/20/5c6d00c51cdeb.png" alt=""><br><img src="https://i.loli.net/2019/02/20/5c6d00cd6252a.png" alt=""><br><img src="https://i.loli.net/2019/02/20/5c6d00d3da7bc.png" alt=""><br><img src="https://i.loli.net/2019/02/20/5c6d00db36d50.png" alt=""></p><h2 id="ZK-特性"><a href="#ZK-特性" class="headerlink" title="ZK 特性"></a>ZK 特性</h2><h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>在 Zookeeper 中，数据结构类似于树，每一个节点叫 <code>ZNode</code>,每一个节点都是有值的。</p><p>我们可以在 Windows 下使用 <code>ZooInspector</code> 客户端工具查看。</p><p><img src="https://i.imgur.com/jLRsYQX.png" alt="ZooInspector"></p><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><p>1）临时节点</p><p>  当与客户端断开连接会 ZNode 自动删除</p><p>2）持久节点</p><p>  当与客户端断开连接会 ZNode 还在</p><p>3） 顺序节点</p><p>  当两个同样的命令执行会自增，<code>create /node1 0000001</code>； <code>create /node1 0000002</code>；非顺序节点会报错</p><p>当节点名称带序号时，创建同样的节点会自增，如果不带序号创建同名节点会报错。也就是说，<b>对于持久节点和临时节点，同一个 Znode 下，节点名称是唯一的。<b></p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>Watcher 即为 Zookeeper 发生节点变更时触发的事件，利用此机制我们可以监听变化做出操作。具体使用详见 </p><h2 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h2><p>配置中心，服务注册与发现，分布式锁，选举。</p><p>以上所有内容可参考<a href="https://github.com/pleuvoir/reference-samples/tree/master/zk-sample" target="_blank" rel="noopener">代码示例</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 重复消费</title>
      <link href="/2019/02/18/rabbitmq-chong-fu-xiao-fei/"/>
      <url>/2019/02/18/rabbitmq-chong-fu-xiao-fei/</url>
      
        <content type="html"><![CDATA[<p>本文记录 RabbitMQ 重复消费的思路以及解决方案。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="生产者重试"><a href="#生产者重试" class="headerlink" title="生产者重试"></a>生产者重试</h3><p>RabbitMQ 提供事务机制，但由于极大降低性能，故不在本文讨论范畴之中。常见的为了保证消息的成功到达 broker，可以选择开启发送方异步确认模式。broker 在收到消息后会回调应用程序 ack 或者 nack。什么时候回调是由 broker 自己决定，当负载较高时可能需要更久的时间。 一般而言，当收到 ack 时我们认为消息已成功到达 broker 并且已经处理成功，nack 代表消息已经丢失（注意：丢失的消息也有可能已经投递给消费者，broker 也不清楚是什么情况）。网上很多博客一般解决可靠投递问题，都会选择在此处做文章。譬如：使用消息记录表维护状态，收到 ack 时为已投递，nack 为投递失败；还有种是没收到 ack 或者 nack 时会用分布式定时任务去扫进行重试。</p><blockquote><p>Acks represent messages handled successfully; Nacks represent messages lost by the broker.  Note, the lost messages<br>could still have been delivered to consumers, but the broker cannot guarantee this.</p></blockquote><p>换言之，采用这种策略是没什么问题。但是因为重试带来了新的问题，消息的重复。</p><h3 id="消费者确认异常"><a href="#消费者确认异常" class="headerlink" title="消费者确认异常"></a>消费者确认异常</h3><p>自动 ack 并不存在这种问题，因为消息离开 broker 就已经被移除了。我们来看看手动 ack：</p><ol><li><p>业务代码报错了，ack 没执行，此种情况会发生在 ack 没放在 finally 的情况下。需不需要放在 finally 代码块中取决于业务。之前还遇到过依赖的 redis 集群网络闪断导致业务代码报错而能确认。</p></li><li><p>ack 时超时了</p></li><li><p>ack broker 收到了，但 broker 出问题了</p></li></ol><p>RabbitMQ 会在消费者连接断开后将 unacked 的消息重新投递给消费者，当然也可能会发送给原来的消费者。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>生产者不重试，消费者做幂等。</p><p>消费者做幂等一般有如下几种情况：</p><ol><li>业务天然是幂等的</li></ol><p>比如 <code>update user_acc set banlance = 100 where userId = &quot;001&quot;</code>，这种情况就不用处理了。</p><ol start="2"><li>乐观锁</li></ol><p>使用乐观锁控制，如果抛出乐观锁异常则 ack 即可，当然其他可以判断业务是否执行过的方式也可以。</p><ol start="3"><li>消息表</li></ol><p>通过消息表来确认消息消费状态，当消费成功时不在进行处理即可。切记，消息表状态的更新必须和业务放在同一个事务中，并且是最后一步。</p><ol start="4"><li>redis</li></ol><p>和消息表的原理类似，使用 redis 来进行消息状态的控制。尤其是 <code>spring-data-redis</code> 提供了面向对象的 <code>CRUD</code> 形式，使我们可以更方便的操作内存数据库。但是这种实现存在风险，如果 redis 已写，但是数据库事务提交失败则存在问题，所以这种方案是不可靠的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><code>spring-amqp</code> 提供了更方便的方法去使用 RabbitMQ，可以通过学习源码的形式了解其面对异常时的思路，譬如，自动应答时面对 io 异常是如何处理的。</p><p>生产者发送消息时默认提供标识，避免驳杂的标识，如使用 uuid。</p><pre><code class="java">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Beanpublic RabbitTemplate getRabbitTemplate(ConnectionFactory connectionFactory) {    RabbitTemplate template = new RabbitTemplate(connectionFactory);    template.setBeforePublishPostProcessors(new MessagePostProcessor() { // 携带消息 id        @Override        public Message postProcessMessage(Message message) throws AmqpException {            MessageProperties messageProperties = message.getMessageProperties();            ThreadLocalRandom random = ThreadLocalRandom.current();            UUID fastUUID = new UUID(random.nextLong(), random.nextLong());            messageProperties.setMessageId(fastUUID.toString().replaceAll(&quot;-&quot;, &quot;&quot;));            return message;        }    });    return template;}</code></pre><p>使用模版方法，将业务代码和消费幂等处理的操作分离开。</p><pre><code class="java">@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)public &lt;T&gt; T excute(RabbitConsumeCallBack&lt;T&gt; callBack, String messageId) {    checkCallBack(callBack);    T result = callBack.doInTransaction();    logger.info(&quot;已经更新为消息处理成功，messageId={}&quot;, messageId);    return result;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qmq 动态刷新配置文件的套路</title>
      <link href="/2018/12/11/qmq-dong-tai-shua-xin-pei-zhi-wen-jian-de-tao-lu/"/>
      <url>/2018/12/11/qmq-dong-tai-shua-xin-pei-zhi-wen-jian-de-tao-lu/</url>
      
        <content type="html"><![CDATA[<p>本文是对 qmq 中动态加载配置类的简要分析以及学习。该功能实现了 <code>properties</code> 文件向通用接口的转换，可以方便的获取属性文件中对应的值，并且实现了实时刷新的功能。</p><h2 id="设计概览"><a href="#设计概览" class="headerlink" title="设计概览"></a>设计概览</h2><h3 id="接口及现有的实现"><a href="#接口及现有的实现" class="headerlink" title="接口及现有的实现"></a>接口及现有的实现</h3><p><code>DynamicConfig</code> 接口是作者对 <code>properties</code> 文件对象转换的抽象，提供了方便的方法让我们来获取文件中定义的值。</p><pre><code>public interface DynamicConfig {    void addListener(Listener listener);    String getString(String name);    String getString(String name, String defaultValue);    int getInt(String name);    boolean exist(String name);    Map&lt;String, String&gt; asMap();    // 省略其他...}</code></pre><p><code>DynamicConfigFactory</code> 是一个动态配置创建工厂方法接口，目前该项目中只实现了本地文件的创建，后期可能会加入远程文件的读取创建实现。</p><pre><code class="java">public interface DynamicConfigFactory {    DynamicConfig create(String name, boolean failOnNotExist);}</code></pre><p><code>DynamicConfigLoader</code> 动态配置加载器，该类即是程序的入口。通过调用 <code>load</code> 方法，即可获得 <code>DynamicConfig</code></p><pre><code class="java">public final class DynamicConfigLoader {    private static final DynamicConfigFactory FACTORY;    static {        ServiceLoader&lt;DynamicConfigFactory&gt; factories = ServiceLoader.load(DynamicConfigFactory.class);        DynamicConfigFactory instance = null;        for (DynamicConfigFactory factory : factories) {            instance = factory;            break;        }        FACTORY = instance;    }    private DynamicConfigLoader() {    }    public static DynamicConfig load(final String name) {        return load(name, true);    }    public static DynamicConfig load(final String name, final boolean failOnNotExist) {        return FACTORY.create(name, failOnNotExist);    }}</code></pre><p>通过工厂方法创建一个动态配置。目前只有本地文件读取创建，这个类由于是名义上的单例，所以成员变量必须考虑为线程安全的：</p><pre><code class="java">public class LocalDynamicConfigFactory implements DynamicConfigFactory {    private final ConfigWatcher watcher = new ConfigWatcher();    // 配置文件观察者，当文件发生变动时会重新加载文件，并通知监听器    private final ConcurrentMap&lt;String, LocalDynamicConfig&gt; configs = new ConcurrentHashMap&lt;&gt;();    // 每一个文件都对应一个 LocalDynamicConfig 类    @Override    public DynamicConfig create(final String name, final boolean failOnNotExist) {        if (configs.containsKey(name)) {            return configs.get(name);        }        return doCreate(name, failOnNotExist);    }    private LocalDynamicConfig doCreate(final String name, final boolean failOnNotExist) {        // putIfAbsent 如果不存在就 put 并且不返回值，否则就 get，正常情况第一次放返回为 null        final LocalDynamicConfig prev = configs.putIfAbsent(name, new LocalDynamicConfig(name, failOnNotExist));        // 不管之前有没有，反正现在一定是可以拿到的        final LocalDynamicConfig config = configs.get(name);        // 如果之前的为空，则代表是并发第一次操作，加入监听，触发事件        if (prev == null) {            watcher.addWatch(config);            config.onConfigModified();        }        return config;    }}</code></pre><p>这里为什么非要 <code>putIfAbsent</code> 原因就在于它类似于 <code>redis</code> 的 <code>setNX</code>，可以用来判断是否占位成功。如果为空则是我们预期的，可以通知监听器（如果有的话），开启监听线程。否则会出现，并发时加入多次的问题。</p><p><code>ConfigWatcher</code> 配置文件观察者，使用单线程池轮询所有文件 <code>lastModified</code> 变化，当侦听到变化时会更新对象中值，用于下次做比较。同时调用 <code>LocalDynamicConfig</code> 的 <code>onConfigModified</code> 方法，该方法会执行实际的文件加载，以及通知所有的自定义的监听器。同样该类也是理论单例，所以设计时也是线程安全的。</p><pre><code class="java">    private final CopyOnWriteArrayList&lt;Watch&gt; watches; // 线程安全的 list，并且适合多读少些，显然这里读操作多，基本上 addWatcher 只会在启动时调用    private final ScheduledExecutorService watcherExecutor;    ConfigWatcher() {        this.watches = new CopyOnWriteArrayList&lt;&gt;();        this.watcherExecutor = Executors.newSingleThreadScheduledExecutor();    // 同时只有一个线程执行，可以保证线程执行的顺序和投入线程池的顺序一致（此处并未用到此特性）        start();    }    private void start() {        watcherExecutor.scheduleWithFixedDelay(new Runnable() {            @Override            public void run() {                checkAllWatches();            }        }, 10, 10, TimeUnit.SECONDS);     // 10 秒执行一次文件检查    }    // 如果有多个线程在检测文件变化，那么同一个对象的修改时间一定是要及时刷新的    private void checkWatch(final Watch watch) {        final LocalDynamicConfig config = watch.getConfig();        final long lastModified = config.getLastModified();        if (lastModified == watch.getLastModified()) {            return;        }        watch.setLastModified(lastModified);        config.onConfigModified();    }    private static final class Watch {        private final LocalDynamicConfig config;        private volatile long lastModified;        // 注意这里是 volatile        private Watch(final LocalDynamicConfig config) {            this.config = config;        }        // 省略 ..    }</code></pre><p><code>LocalDynamicConfig</code> 是动态接口的实现，主要功能是完成文件的加载，以及</p><pre><code class="java">    // 这些都是 volatile 原因是会共享    private volatile File file;    private volatile boolean loaded = false;    private volatile Map&lt;String, String&gt; config;    // 获取文件，目的是为了获取文件的上次修改时间   private File getFileByName(final String name) {        try {            final URL res = this.getClass().getClassLoader().getResource(name);            if (res == null) {                return null;            }            return Paths.get(res.toURI()).toFile();        } catch (URISyntaxException e) {            throw new RuntimeException(&quot;load config file failed&quot;, e);        }    }  // 文件转化为 Properties  private void loadConfig() {        try {            final Properties p = new Properties();            try (Reader reader = new BufferedReader(new FileReader(file))) {                p.load(reader);            }            // 转为 map，每次重新载入时都会 new 新的 map            final Map&lt;String, String&gt; map = new LinkedHashMap&lt;&gt;(p.size());            for (String key : p.stringPropertyNames()) {                map.put(key, tryTrim(p.getProperty(key)));            }            config = Collections.unmodifiableMap(map);    // 再走一步，转为不可修改的，防止小白修改了对象属性        } catch (IOException e) {            e.printStackTrace();        }    }  synchronized void onConfigModified() {        if (file == null) {            return;        }        loadConfig();        executeListeners(); // 其实就是循环调用 listener.onLoad(this); 监听器载入本类，嗯很合理。这个接口需要我们自己实现。        loaded = true;    }</code></pre><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><pre><code class="java">// DynamicConfig 是一个通用的接口，可以方便的获取值DynamicConfig config = DynamicConfigLoader.load(&quot;config/appconfig.properties&quot;);config.addListener(new Listener() {    @Override    public void onLoad(DynamicConfig config) {        System.out.println(&quot;当文件被修改，被检测到后会执行我被重新载入了。。&quot;);    }});// 可以修改文件试试，会发现动态刷新了while(true) {    TimeUnit.SECONDS.sleep(1);    System.out.println(config.getString(&quot;app.name&quot;)); }</code></pre><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><pre><code class="java">private static final DynamicConfigFactory FACTORY;static {    ServiceLoader&lt;DynamicConfigFactory&gt; factories = ServiceLoader.load(DynamicConfigFactory.class);    DynamicConfigFactory instance = null;    for (DynamicConfigFactory factory : factories) {        instance = factory;        //第一个即为实现，忽略后面的        break;    }    FACTORY = instance;}</code></pre><p>此项技术使用了 java 的 spi，约定如下，在 <code>resource</code> 目录下新建 <code>META-INF\services</code> 目录，新建文件名称为接口的权限定类名（注意此文件是无格式的），在此例中为 <code>io.github.pleuvoir.qmq.DynamicConfigFactory</code>，文件内容为该接口的实现类，这里是 <code>io.github.pleuvoir.qmq.local.LocalDynamicConfigFactory</code>。这样当如上的代码加载时，<code>DynamicConfigFactory</code> 即指向了文件中配置的实现，同时实现类会被初始化。</p><h3 id="j-u-c"><a href="#j-u-c" class="headerlink" title="j.u.c"></a>j.u.c</h3><ul><li><code>CopyOnWriteArrayList</code></li><li><code>Executors.newSingleThreadScheduledExecutor</code></li><li><code>scheduleWithFixedDelay</code></li><li><code>putIfAbsent</code></li><li><code>volatile</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 套路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP 配置文件使用的套路</title>
      <link href="/2018/12/08/hikaricp-pei-zhi-wen-jian-shi-yong-de-tao-lu/"/>
      <url>/2018/12/08/hikaricp-pei-zhi-wen-jian-shi-yong-de-tao-lu/</url>
      
        <content type="html"><![CDATA[<p>本文是对一个配置类的简要分析，其中隐藏了不易被关注的细节，并对作者使用的技巧进行学习。</p><p><code>HikariCP</code> 中有一个面向对象的类 <code>HikariConfig</code> ，为什么说它是面向对象的，原因是因为常规对 <code>properties</code> 文件读取后，会直接加载到需要的位置，而此类会通过反射进行属性的转化。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><h3 id="loadProperties"><a href="#loadProperties" class="headerlink" title="loadProperties"></a>loadProperties</h3><p>其中有一个方法，是用来加载文件：</p><pre><code class="java">private void loadProperties(String propertyFileName) {    final File propFile = new File(propertyFileName);    InputStream resourceAsStream = this.getClass().getResourceAsStream(propertyFileName);    try (final InputStream is = propFile.isFile() ? new FileInputStream(propFile) : this.getClass().getResourceAsStream(propertyFileName)) {        if (is != null) {            Properties props = new Properties();            props.load(is);            // 这段代码使用了反射完成了 Properties 到本对象的转换            PropertyElf.setTargetFromProperties(this, props);        } else {            throw new IllegalArgumentException(&quot;Cannot find property file: &quot; + propertyFileName);        }    } catch (IOException io) {        throw new RuntimeException(&quot;Failed to read property file&quot;, io);    }}</code></pre><p>其中该方法支持两种形式的入参，第一种是使用物理绝对路径，如 <code>F:\\git\\luxury-lunch\\src\\test\\resources\\HikariConfigTest.properties</code>；当然，我们也可以使用相对路径，如 <code>/HikariConfigTest.properties</code>，注意一定要有 <code>/</code>，<code>/</code>表示从 <code>classpath</code> 下寻找该文件。具体使用可以参考 <a href="http://www.cnblogs.com/macwhirr/p/8116583.html" target="_blank" rel="noopener">Java 中 getResourceAsStream 的用法</a></p><p>显然，我们一般都会使用相对路径。同时，这段代码使用了 <code>try-resource</code> 风格，可以优雅的关闭文件流。所以，这段读取 <code>properties</code> 文件的代码现已加入豪华午餐。</p><h3 id="copyStateTo"><a href="#copyStateTo" class="headerlink" title="copyStateTo"></a>copyStateTo</h3><p>复制状态，该方法通过反射将本类 <code>HikariConfig</code> 自身的属性值赋值给一个新创建的 <code>HikariConfig</code></p><pre><code class="java">public void copyStateTo(HikariConfig other) {    for (Field field : HikariConfig.class.getDeclaredFields()) {        if (!Modifier.isFinal(field.getModifiers())) {            field.setAccessible(true);            try {                field.set(other, field.get(this));            } catch (Exception e) {                throw new RuntimeException(&quot;Failed to copy HikariConfig state: &quot; + e.getMessage(), e);            }        }    }}</code></pre><p>该示例经过测试发现，当属性为基本类型时，反射复制没有问题，即使修改原复制对象的属性，新对象也不会受到影响。注意：一旦原复制对象中有非基本类型，那么复制以后新对象的这些非基本类型也会被修改。</p><p>浅拷贝（Shallow Copy）：</p><ol><li><p>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p></li><li><p>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</p></li></ol><p>所以这个方法和浅拷贝的用处是一样的，同样实现浅拷贝的方法还有实现 <code>Cloneable</code> 接口，直接重写 <code>clone()</code> 方法，通过调用 <code>clone</code> 方法即可完成浅拷贝。</p><p>参考：<a href="https://www.cnblogs.com/shakinghead/p/7651502.html" target="_blank" rel="noopener">浅拷贝与深拷贝</a></p><h3 id="getPropertyNames"><a href="#getPropertyNames" class="headerlink" title="getPropertyNames"></a>getPropertyNames</h3><p>获取类中所有 <code>field</code> 的集合，过滤重复。</p><pre><code class="java">private static final Pattern GETTER_PATTERN = Pattern.compile(&quot;(get|is)[A-Z].+&quot;);public static Set&lt;String&gt; getPropertyNames(final Class&lt;?&gt; targetClass) {    HashSet&lt;String&gt; set = new HashSet&lt;&gt;();    Matcher matcher = GETTER_PATTERN.matcher(&quot;&quot;);    for (Method method : targetClass.getMethods()) {        String name = method.getName();        if (method.getParameterTypes().length == 0 &amp;&amp; matcher.reset(name).matches()) {  // 获取 get 或 is 开头的方法            name = name.replaceFirst(&quot;(get|is)&quot;, &quot;&quot;);    //  isAutoCommit 会被改为 AutoCommit            try {                 if (targetClass.getMethod(&quot;set&quot; + name, method.getReturnType()) != null) {  //这里检查名称为 setAutoCommit 且入参类型为 boolean 的方法存在不存在，显然是存在的                    name = Character.toLowerCase(name.charAt(0)) + name.substring(1);        // 认为属性名是 autoCommit，所以是不对的                    set.add(name);                }            } catch (Exception e) {                // fall thru (continue)            }        }    }    return set;}</code></pre><p>这个方法其实是有问题的，当属性值为 <code>boolean</code> 类型时，需要注意如果字段名为 <code>isAutoCommit</code> 或者 <code>autoCommit</code>，<code>IDE</code> 帮我们生成的 <code>get</code> 方法都是 <code>isAutoCommit</code>， <code>set</code> 方法都是 <code>setAutoCommit</code>。<br>所以，直接将方法名称中 <code>get 或者 set</code> 替换空是不严谨的。</p><p>所以，同时也是很多代码规范中的要求，不要给 <code>boolean</code> 类型的变量加 <code>is</code>，原因就在此。</p><h3 id="setTargetFromProperties"><a href="#setTargetFromProperties" class="headerlink" title="setTargetFromProperties"></a>setTargetFromProperties</h3><p>该方法是将 <code>properties</code> 文件中各个值反射设置给类的属性。但是原代码中不支持 <code>double</code> 类型，所以做了一下修改。</p><pre><code class="java">// 尝试使用类中变量名进行转换，如果类型为布尔且以 is 开头，请配置 properties 文件时去除 is，否则会报错private static void setProperty(final Object target, final String propName, final Object propValue,        final List&lt;Method&gt; methods) {  String methodName = &quot;set&quot; + propName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propName.substring(1);  Method writeMethod = methods.stream().filter(m -&gt; m.getName().equals(methodName) &amp;&amp; m.getParameterCount() == 1).findFirst().orElse(null);  // 这里布尔类型会有问题，建议在类中设置布尔类型的变量时是不要以 is 开头，如果已经使用了 is 开头，那么 properties 文件中的 key 请去掉 is  if (writeMethod == null) {     String booleanMethodName =  &quot;is&quot; + propName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propName.substring(1);     writeMethod = methods.stream().filter(m -&gt; m.getName().equals(booleanMethodName) &amp;&amp; m.getParameterCount() == 1).findFirst().orElse(null);  }  if (writeMethod == null) {     throw new RuntimeException(String.format(&quot;Property %s does not exist on target %s&quot;, propName, target.getClass()));  }  try {      // 根据参数类型尝试     Class&lt;?&gt; paramClass = writeMethod.getParameterTypes()[0];     if (paramClass == int.class) {        writeMethod.invoke(target, Integer.parseInt(propValue.toString()));     }     else if (paramClass == long.class) {        writeMethod.invoke(target, Long.parseLong(propValue.toString()));     }     else if (paramClass == boolean.class || paramClass == Boolean.class) {        writeMethod.invoke(target, Boolean.parseBoolean(propValue.toString()));     }     else if (paramClass == String.class) {        writeMethod.invoke(target, propValue.toString());     }     else if (paramClass == double.class) {        writeMethod.invoke(target, Double.valueOf(propValue.toString()));     }     else {        try {           writeMethod.invoke(target, Class.forName(propValue.toString()).newInstance());        }        catch (InstantiationException | ClassNotFoundException e) {           writeMethod.invoke(target, propValue);        }     }  }  catch (Exception e) {     throw new RuntimeException(e);  }}</code></pre><p>可以完成文件到对象的转换！简直 nice :blush:</p><h2 id="特殊的思路"><a href="#特殊的思路" class="headerlink" title="特殊的思路"></a>特殊的思路</h2><p>一个类需要使用另一个类的配置，我们一般都是注入，然而作者的思路是，这个类直接继承另一个类。如下：</p><pre><code class="java">public class HikariDataSource extends HikariConfig {    // 传统做法    private HikariConfig hikariConfig;    public HikariDataSource(HikariConfig configuration) {    //    configuration.copyStateTo(this); // 这行会进行属性拷贝 ，这是作者的做法，优势是当属性值很多时可以不用再去每次都去用别的类点调用        this.hikariConfig = configuration; // 传统做法    }    public void dosomething1() {        System.out.println(&quot;驱动名称有了：&quot; + hikariConfig.getDriverClassName()); // 这里就显得比较啰嗦    }    public void dosomething2() {        System.out.println(&quot;驱动名称有了：&quot; + getDriverClassName());  // 简单    }}</code></pre><p>其实这段代码并不复杂，主要是我们能不能想到这么做很关键。</p><h2 id="豪华午餐"><a href="#豪华午餐" class="headerlink" title="豪华午餐"></a>豪华午餐</h2><pre><code class="java">// 获得的豪华午餐Properties props = PropLoaderUtil.loadProperties(propertyFileName);// 反射拷贝属性，浅拷贝小心拷贝对象中引用类型的改变User copyStateTo = CopyStateUtil.copyStateTo(source, target, User.class);CopyStateUtil.copyStateTo(source, target);Cloneable 接口的使用：@Overrideprotected User clone() {    User user = null;    try {        user = (User) super.clone();    } catch (CloneNotSupportedException e) {        e.printStackTrace();    }    return user;}// 完成文件到对象的转换，不存在的属性会报错，以后新建了对象然后将属性贴到文件中即可使用了PropLoaderUtil.setTargetFromProperties(myHikariConfig, &quot;/HikariConfigTest.properties&quot;);</code></pre><p>最佳实践</p><pre><code class="java">public class AppConfig {private static final AppConfig INSTANCE = new AppConfig();private String name;private String name2;private String name3;private String name4;private String name5;private String name6;private String name7;private String name8;private String version;private boolean complete;public static AppConfig load(String propPath) {    return PropLoaderUtil.setTargetFromProperties(INSTANCE, propPath, &quot;app.&quot;);}public void copyStateTo(Object target) {    CopyStateUtil.copyStateTo(this, target);}// 省略 get and set</code></pre><pre><code class="java">public class Bootstrap extends AppConfig {    public Bootstrap(AppConfig appConfig) {        appConfig.copyStateTo(this);        // 如此，appConfig 中属性值已经可以直接 getXXX 了，否则还得 appConfig.getXXX，当属性多时有特效    }}</code></pre><pre><code>//文件内容app.name=luxury-lunchapp.name2=luxury-lunch2app.name3=luxury-lunch3app.name4=luxury-lunch4app.name5=luxury-lunch5app.name6=luxury-lunch6app.name7=luxury-lunch7app.version=20181208app.complete=false</code></pre><pre><code class="java">// 使用Bootstrap bootstrap = new Bootstrap(AppConfig.load(&quot;/config/appconfig.properties&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源 </tag>
            
            <tag> 套路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布开源项目到 Sonatype</title>
      <link href="/2018/11/04/fa-bu-kai-yuan-xiang-mu-dao-sonatype/"/>
      <url>/2018/11/04/fa-bu-kai-yuan-xiang-mu-dao-sonatype/</url>
      
        <content type="html"><![CDATA[<p>本文旨在记录在没有私有 maven 仓库的情况下，如何发布项目到公有仓库。以便在有网络的情况下，使用 maven 坐标获取。</p><h2 id="一、Sonatype-简介"><a href="#一、Sonatype-简介" class="headerlink" title="一、Sonatype 简介"></a>一、Sonatype 简介</h2><p>Sonatype 使用 Nexus 为开源项目提供托管服务。你可以通过它发布快照 (snapshot) 或是稳定版 (release) 到 Maven 中央仓库。我们只要注册一个 Sonatype 的 JIRA 账号、创建一个 JIRA ticket，然后对 POM 文件稍作配置即可。</p><h2 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h2><h3 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1. 注册账号"></a>1. 注册账号</h3><p>打开 <a href="https://issues.sonatype.org" target="_blank" rel="noopener" title="https://issues.sonatype.org ">https://issues.sonatype.org</a> 注册账号，需要注意的是密码必须超过 12 位，且包含至少一个大写字符，一个小写字符，一个特殊字符，以及不少于三种的不同字符（字符，数字，符号）。描述的有些拗口，简单说就是包含大写字母、小写字符、符号和数字，并且超过 12 位即可。所以密码类似于 <code>Ff123456789/</code> 这样的。</p><h3 id="2-创建-issue"><a href="#2-创建-issue" class="headerlink" title="2. 创建 issue"></a>2. 创建 issue</h3><p>登录成功后，打开 <a href="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&pid=10134" target="_blank" rel="noopener" title="https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134">https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134</a></p><p>其中 Summary 可以填写项目名</p><p>Description 填写项目介绍</p><p>groupId <code>io.github.pleuvoir</code> (你的)</p><p>Project URL 和 SCM url 可以填写 github 项目对应的访问地址</p><p>点击创建后会发起一个 issue，会发现状态变为 <code>OPEN</code> 接下来要做的就是耐心的等待，等待官方审核。为了方便后续查看，这里是此次演示使用的查看审核状态地址 <a href="https://issues.sonatype.org/browse/OSSRH-43847" target="_blank" rel="noopener" title="https://issues.sonatype.org/browse/OSSRH-43847">查看审核状态</a>。此次演示出乎意料，5 分钟之内被审核通过。如下图示例:</p><p><img src="https://i.imgur.com/9oiOCvW.png" alt=""></p><p>可以看到，这是官方给出的评论说明。注意相关提示最后一点，当我们发布第一版 release 时，需要评论一次。</p><blockquote><p>Permalink<br>central-ossrh Central OSSRH added a comment - 5 minutes ago<br>io.github.pleuvoir has been prepared, now user(s) pleuvoir can:</p></blockquote><blockquote><p>Deploy snapshot artifacts into repository <a href="https://oss.sonatype.org/content/repositories/snapshots" target="_blank" rel="noopener">https://oss.sonatype.org/content/repositories/snapshots</a><br>Deploy release artifacts into the staging repository <a href="https://oss.sonatype.org/service/local/staging/deploy/maven2" target="_blank" rel="noopener">https://oss.sonatype.org/service/local/staging/deploy/maven2</a><br>Promote staged artifacts into repository ‘Releases’<br>Download snapshot and release artifacts from group <a href="https://oss.sonatype.org/content/groups/public" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/public</a><br>Download snapshot, release and staged artifacts from staging group <a href="https://oss.sonatype.org/content/groups/staging" target="_blank" rel="noopener">https://oss.sonatype.org/content/groups/staging</a><br>please comment on this ticket when you promoted your first release, thanks</p></blockquote><h3 id="3-修改项目"><a href="#3-修改项目" class="headerlink" title="3. 修改项目"></a>3. 修改项目</h3><h4 id="安装-GPG"><a href="#安装-GPG" class="headerlink" title="安装 GPG"></a>安装 GPG</h4><p>用于对需要上传的文件加密和签名，<code>windows</code> 环境下载地址 <a href="http://gpg4win.org/" target="_blank" rel="noopener" title="http://gpg4win.org/">GPG</a>，下载有些慢，如有需要可从第三方源进行下载</p><p>安装完成后在命令行输入 <code>gpg --gen-key</code> 命令生成自己的 public key，除了姓名、邮箱、备注外其他都可以使用默认配置，最后需要填写一个 passphase（数字即可比如: <code>62107872006</code>），它在后面 mvn release 签名时会用到。</p><p>最后控制台会显示如下画面:</p><p><img src="https://i.imgur.com/66XdZPN.png" alt=""></p><p>其中 <code>1FEA509E</code> 即为需要上报的 key id，如果错过了这个画面，可以使用 <code>gpg --list-keys</code> 命令查看 key 内容。</p><p>上报 key id 给服务器 <code>gpg --keyserver hkp://pool.sks-keyservers.net --send-keys [你的 key id]</code></p><p>需要等待执行完毕，不要随便关闭。上报成功后结束，进行下一个环节项目发布。</p><p>可以使用 <code>gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys [你的 key id]</code> 查看是否发布成功</p><h4 id="修改-pom"><a href="#修改-pom" class="headerlink" title="修改 pom"></a>修改 pom</h4><pre><code class="xml">&lt;!-- Configuration for maven central repository --&gt;    &lt;profiles&gt;        &lt;profile&gt;            &lt;id&gt;release&lt;/id&gt;            &lt;build&gt;                &lt;plugins&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.sonatype.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;nexus-staging-maven-plugin&lt;/artifactId&gt;                        &lt;version&gt;1.6.3&lt;/version&gt;                        &lt;extensions&gt;true&lt;/extensions&gt;                        &lt;configuration&gt;                            &lt;serverId&gt;oss&lt;/serverId&gt;                            &lt;nexusUrl&gt;https://oss.sonatype.org/&lt;/nexusUrl&gt;                            &lt;autoReleaseAfterClose&gt;true&lt;/autoReleaseAfterClose&gt;                        &lt;/configuration&gt;                    &lt;/plugin&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;maven-gpg-plugin&lt;/artifactId&gt;                        &lt;version&gt;1.6&lt;/version&gt;                        &lt;executions&gt;                            &lt;execution&gt;                                &lt;phase&gt;verify&lt;/phase&gt;                                &lt;goals&gt;                                    &lt;goal&gt;sign&lt;/goal&gt;                                &lt;/goals&gt;                            &lt;/execution&gt;                        &lt;/executions&gt;                    &lt;/plugin&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;                        &lt;version&gt;3.0.1&lt;/version&gt;                        &lt;executions&gt;                            &lt;execution&gt;                                &lt;phase&gt;package&lt;/phase&gt;                                &lt;goals&gt;                                    &lt;goal&gt;jar-no-fork&lt;/goal&gt;                                &lt;/goals&gt;                            &lt;/execution&gt;                        &lt;/executions&gt;                    &lt;/plugin&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                        &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;                        &lt;version&gt;3.0.0&lt;/version&gt;                        &lt;configuration&gt;                            &lt;failOnError&gt;false&lt;/failOnError&gt;                            &lt;doclint&gt;none&lt;/doclint&gt;                        &lt;/configuration&gt;                        &lt;executions&gt;                            &lt;execution&gt;                                &lt;phase&gt;package&lt;/phase&gt;                                &lt;goals&gt;                                    &lt;goal&gt;jar&lt;/goal&gt;                                &lt;/goals&gt;                            &lt;/execution&gt;                        &lt;/executions&gt;                    &lt;/plugin&gt;                &lt;/plugins&gt;            &lt;/build&gt;            &lt;distributionManagement&gt;                &lt;snapshotRepository&gt;                    &lt;id&gt;oss&lt;/id&gt;                    &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/url&gt;                &lt;/snapshotRepository&gt;                &lt;repository&gt;                    &lt;id&gt;oss&lt;/id&gt;                    &lt;url&gt;https://oss.sonatype.org/service/local/staging/deploy/maven2/&lt;/url&gt;                &lt;/repository&gt;            &lt;/distributionManagement&gt;        &lt;/profile&gt;    &lt;/profiles&gt;    &lt;licenses&gt;        &lt;license&gt;            &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;            &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;        &lt;/license&gt;    &lt;/licenses&gt;    &lt;!-- 修改这里 --&gt;    &lt;scm&gt;        &lt;url&gt;https://github.com/pleuvoir/plugins-support&lt;/url&gt;        &lt;connection&gt;scm:git:https://github.com/pleuvoir/plugins-support.git&lt;/connection&gt;        &lt;developerConnection&gt;scm:git:https://github.com/pleuvoir/plugins-support.git&lt;/developerConnection&gt;        &lt;tag&gt;v${project.version}&lt;/tag&gt;    &lt;/scm&gt;    &lt;!-- 修改这里 --&gt;    &lt;developers&gt;        &lt;developer&gt;            &lt;name&gt;pleuvoir&lt;/name&gt;            &lt;email&gt;pleuvior@foxmail.com&lt;/email&gt;            &lt;url&gt;https://pleuvoir.github.io&lt;/url&gt;        &lt;/developer&gt;    &lt;/developers&gt;</code></pre><h4 id="修改-setting"><a href="#修改-setting" class="headerlink" title="修改 setting"></a>修改 setting</h4><pre><code class="xml">&lt;!-- Sonatype 账号 --&gt;&lt;settings&gt;  &lt;servers&gt;    &lt;server&gt;      &lt;id&gt;oss&lt;/id&gt;      &lt;username&gt;修改这里 your-jira-id&lt;/username&gt;      &lt;password&gt;修改这里 your-jira-pwd&lt;/password&gt;    &lt;/server&gt;  &lt;/servers&gt;&lt;/settings&gt;&lt;!-- 配置 gpg 的签名 --&gt;&lt;settings&gt;  &lt;profiles&gt;    &lt;profile&gt;      &lt;id&gt;oss&lt;/id&gt;      &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;/activation&gt;      &lt;properties&gt;        &lt;gpg.executable&gt;gpg2&lt;/gpg.executable&gt;        &lt;gpg.passphrase&gt;修改这里 the_pass_phrase&lt;/gpg.passphrase&gt;      &lt;/properties&gt;    &lt;/profile&gt;  &lt;/profiles&gt;&lt;/settings&gt;</code></pre><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p><code>mvn clean deploy -DskipTests -P release</code></p><h3 id="4-搜索项目"><a href="#4-搜索项目" class="headerlink" title="4. 搜索项目"></a>4. 搜索项目</h3><p>打开 <a href="https://oss.sonatype.org" target="_blank" rel="noopener">https://oss.sonatype.org</a>，search <code>io.github.pleuvoir</code> 即可找到上传的项目信息。</p><p>如果是第一次 release，需要回复创建的 issue.</p><h2 id="三、遇到的问题"><a href="#三、遇到的问题" class="headerlink" title="三、遇到的问题"></a>三、遇到的问题</h2><pre><code class="bash">[ERROR]  * No public key: Key with id: (491134901fea509e) was not able to belocated on &amp;lt;a href=http://keys.gnupg.net:11371/&amp;gt;http://keys.gnupg.net:11371/&amp;lt;/a&amp;gt;. Upload your public key and try the operation again.</code></pre><p>原因: 各种 OpenPGP 密钥服务器同步需要一些时间。</p><p>解决方法: 如果你知道哪个密钥服务器会被查询，你可以直接在那里上传你的密钥。</p><p><code>gpg --keyserver hkp://keys.gnupg.net --send-keys [你的 key id]</code><br><code>gpg --keyserver hkp://keyserver.ubuntu.com --send-keys [你的 key id]</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 人的社会化</title>
      <link href="/2018/09/28/02-ren-de-she-hui-hua/"/>
      <url>/2018/09/28/02-ren-de-she-hui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="人的社会化"><a href="#人的社会化" class="headerlink" title="人的社会化"></a>人的社会化</h1><h2 id="一、什么是社会化"><a href="#一、什么是社会化" class="headerlink" title="一、什么是社会化"></a>一、什么是社会化</h2><h3 id="社会化的简要描述"><a href="#社会化的简要描述" class="headerlink" title="社会化的简要描述"></a>社会化的简要描述</h3><p>我们是什么样的，很大程度上取决于我们生活的环境，而不是基因。</p><p>人类之间的生理相似性（生理结构、生理欲望、学习语言的能力），更多的是社会差异性（多元的文化）</p><p>人的思考方式与行为方式同社会环境之间有着某种联系，而这种联系社会学中用”社会化”来描述。</p><p>社会化: 人们在于社会的互动中，内化社会文化，形成个体人格的过程。</p><h3 id="生活中的社会化"><a href="#生活中的社会化" class="headerlink" title="生活中的社会化"></a>生活中的社会化</h3><p>学雷锋精神，做有志青年。</p><p>社会化存在的证据</p><ul><li>我们在与社会的互动中发展</li><li>情绪的形成取决于互动</li><li>自我认知取决于互动</li><li>互动影响发展，是社会化的一种体现</li></ul><p>人们行为、思考方式的文化差异</p><p>环境塑造行为与人格，是社会化存在的又一个证据</p><p>为什么我们大家彼此这么相像，同时我们之间又如此不同。</p><h3 id="社会学习理论"><a href="#社会学习理论" class="headerlink" title="社会学习理论"></a>社会学习理论</h3><h4 id="行为主义理论"><a href="#行为主义理论" class="headerlink" title="行为主义理论"></a>行为主义理论</h4><ul><li>环境对人的影响，早期的社会学习理论。</li><li>人们会重复带来愉悦结果的动作，压抑带来不好结果的行为，人的发展就是这样简单的机械化对环境反映的过程</li><li>环境决定一切</li></ul><h4 id="认知学习理论"><a href="#认知学习理论" class="headerlink" title="认知学习理论"></a>认知学习理论</h4><ul><li>对人类来讲，不一定亲身经历或惩罚，也可以学习到东西</li><li>观察学习</li><li>通过观察别人（称为榜样）的行为而学习</li><li>延迟模仿</li></ul><p>主动的学习对人类的成长更为重要。认识对学习非常重要。而不是一个机械的对环境的反映过程。</p><h3 id="社会认知理论"><a href="#社会认知理论" class="headerlink" title="社会认知理论"></a>社会认知理论</h3><ul><li>认知图式:认知的结构，也就是我们理解事物的方式。</li><li>儿童认知的发展，重要的在于<strong>结构的转变</strong>，而非信息量的增加。</li></ul><p>儿童是一个建构者，依靠自己的好奇心和主动探索，在于外界的接触中，不断建构起新的认知图式。</p><p><strong>儿童的发展是儿童积极参与的过程，而不是被动接受的过程。</strong></p><h3 id="精神分析学派"><a href="#精神分析学派" class="headerlink" title="精神分析学派"></a>精神分析学派</h3><p>弗洛伊德</p><p>人被强大的、必须满足的生物欲望驱动。<br>“生的本能”:与生命保存有关的本能，吃、喝、性等。<br>“死的本能”:促使返回前生命状态的本能，纵火、斗殴、攻击、自虐等</p><p>性欲 的指向和满足情况，决定了人格发展的过程。</p><p><strong>生物基础对个人发展的作用，也看到了社会在其中的作用（本能的满足情况）</strong></p><h3 id="现代进化论"><a href="#现代进化论" class="headerlink" title="现代进化论"></a>现代进化论</h3><ul><li>习性学:研究人类先天的、本能的反应。”生物程序”设定好的行为–进化的产物–适应生存的环境</li><li>现代进化论</li><li>自然选择的标准不是利于个体的生存，而是个体基因的延续和存活</li><li><strong>生物环境对个体的影响</strong></li><li><strong>环境的作用:影响进化</strong></li></ul><h3 id="交互决定论"><a href="#交互决定论" class="headerlink" title="交互决定论"></a>交互决定论</h3><p>人、行为与环境的关系是双向的。<br>人自己的行为结果会影响环境，环境又会反过来影响人及其行为。</p><h2 id="二、社会化的内容（上）"><a href="#二、社会化的内容（上）" class="headerlink" title="二、社会化的内容（上）"></a>二、社会化的内容（上）</h2><p>自我意识的形成，我是谁？</p><p>关于”自我”的观念是与其他人的互动中形成的。<br>自我并非与生俱来，而是在社会性发展过程中出现的。</p><ul><li>与自我概念有关的并不是实际上别人如何评价我们，而是我们觉得他们如何评价我们。</li><li>在大多数文化中，人们通常偏向于赞扬别人，如果个体因此高估别人对他的评价，其自我印象会变得有些膨胀。</li></ul><p>自我意识是在互动中形成的</p><p>人们通过他人对自己的评价认识自己</p><p>认识自己的依据是我们主观感受到的他人评价。</p><h2 id="二、社会化的内容（下）"><a href="#二、社会化的内容（下）" class="headerlink" title="二、社会化的内容（下）"></a>二、社会化的内容（下）</h2><p>情绪的社会化</p><p>情绪包括:感受 + 生理反应 + 认知 + 目标（采取行动的愿望）</p><p>情绪能力:识别他人情绪的能力 + 调节自己的情绪 + 合乎规范地表达情绪</p><p>情绪的调节:</p><ul><li>关注高兴的事情</li><li>淡化某种情绪</li><li>不想可怕的事情</li><li>换一种方法来理解</li></ul><p>中国人讲究喜怒不形于色，西方人则以丰富的情感表达作为个人魅力的一种展示。</p><p>总结</p><ul><li>情绪的发展受到社会互动影响</li><li>情绪能力包括识别情绪、情绪表达、情绪调节三个方面</li><li>情绪能力的发展受到环境的影响</li><li>情绪能力与社会能力有着密切的关系</li></ul><h2 id="三、社会化的主体"><a href="#三、社会化的主体" class="headerlink" title="三、社会化的主体"></a>三、社会化的主体</h2><p>发挥社会化的功能</p><p>家庭、同辈群体、学校、大众传媒</p><p>家庭:早期的亲密互动会影响到儿童的智力发育。</p><p>家庭结构对儿童的影响</p><p>教养方式影响人的发展</p><h3 id="接纳-反应性"><a href="#接纳-反应性" class="headerlink" title="接纳/反应性"></a>接纳/反应性</h3><p>接纳/反应性，指父母所表现出的支持、关爱程度。</p><ul><li>接纳反应高的父母经常对孩子微笑、赞赏、鼓励，会表达大量的疼爱，当然孩子犯错时他们也会相当严厉。</li><li>接纳性和反应性较低的父母动辄批评、贬损、惩罚孩子，也很少与孩子进行交流，尽管他们很爱孩子。</li></ul><h3 id="要求-控制性"><a href="#要求-控制性" class="headerlink" title="要求/控制性"></a>要求/控制性</h3><p>要求/控制性，指父母对孩子的管束、监控程度。</p><ul><li>要求/控制度高的父母会限制孩子的表达自由:他们会提许多要求，并主动检查孩子的行为以确保这些规则得到了执行。</li><li>控制/要求性较低的父母对孩子的限制少的多，他们很少提要求，在孩子的兴趣爱好和决定自己的事情方面，给孩子相当的自由。</li></ul><p>总结:</p><ul><li>家庭、同辈群体、学校、大众传媒是社会化的主体，发挥着社会化的功能。</li><li>家庭可以提供亲密关系，因为在社会化中有着重要的作用</li><li>家庭结构、关系、兄弟姐妹、教养方式都对儿童的发展有着重要的影响。</li></ul><h2 id="四、一生的社会化"><a href="#四、一生的社会化" class="headerlink" title="四、一生的社会化"></a>四、一生的社会化</h2><p>埃里克森的 8 个阶段:</p><p>第一阶段:</p><p>0-1岁 信任对不信任 </p><p>婴儿必须对满足他们基本需要的人产生信任感，不可随意变更养育着，否则婴儿会把周围世界看成充斥着不可信任和不可靠的人的危险之地。</p><p>第二阶段:</p><p>1-3岁 自主性对羞愧和坏境</p><p>第三阶段:</p><p>3-6岁 主动性对内疚感</p><p>第四阶段:</p><p>6-12 勤奋对自卑</p><p>第五阶段:</p><p>12-20岁 同一性对角色混乱（正确回答我是谁）</p><p>第六阶段:</p><p>20-40岁 亲密对孤独</p><p>第七阶段:</p><p>40-65岁 繁衍感对停滞</p><p>第八阶段:</p><p>65以后 自我整合对失望</p>]]></content>
      
      
      <categories>
          
          <category> 通识教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 什么是社会学</title>
      <link href="/2018/09/27/01-shi-me-shi-she-hui-xue/"/>
      <url>/2018/09/27/01-shi-me-shi-she-hui-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是社会学"><a href="#什么是社会学" class="headerlink" title="什么是社会学"></a>什么是社会学</h1><h2 id="一、社会学的研究对象"><a href="#一、社会学的研究对象" class="headerlink" title="一、社会学的研究对象"></a>一、社会学的研究对象</h2><p>关于社会学的定义是众多的，社会学的研究对象是缺乏共识的。各学派相对比较认同的说法是：如果社会是人类群居生活的共同体，那么社会学是从群体和整体的角度研究人类社会行为的科学。</p><h3 id="社会结构说"><a href="#社会结构说" class="headerlink" title="社会结构说"></a>社会结构说</h3><p>地位结构观：阶级、阶层、性别、年龄、教育、职业、收入、组织、党派 ……</p><p>网络结构观：家庭、亲属、同事、同乡、战友、邻里、朋友、相识 ……</p><h3 id="社会行动说"><a href="#社会行动说" class="headerlink" title="社会行动说"></a>社会行动说</h3><p>人类是有理解力和创造力的主体，人的行为是由动机推动的，个体为了实现某目标而行为，所以行为被赋予了某种意义。社会学旨在理解和洞察人类行为的社会意义。</p><h3 id="社会文化说"><a href="#社会文化说" class="headerlink" title="社会文化说"></a>社会文化说</h3><p>社会的主体是人类，但人类之所以能够共同生活是因为有文化。文化是物质和非物质的人类产品，承载于名族历史、风土人情、传统习俗、生活方式、行为规范、文学艺术、思维方式、价值观念等形式中。文化的核心形态是信仰、价值观、意识形态，是社会制度的基础，规范着人们的社会行为。如果我们将人类社会，人类的社会行为作为研究重点，我们必须要研究文化，从文化的角度去剖析社会。</p><h3 id="社会变迁说"><a href="#社会变迁说" class="headerlink" title="社会变迁说"></a>社会变迁说</h3><p>社会学由于近现代的社会变迁而产生，又以社会变迁为自己的研究己任。社会革命（剧烈的变化、彻头彻尾的变化、是根本的变化、是制度性的变化）和社会改良（渐变的）是两种不同的社会变迁方式，引发了冲突学派和功能学派在社会学领域长期的学术立场的对立和共存。    但冲突学派和功能学派的共同点是都认为社会变迁是社会学研究的根本问题，也就是说社会学就是要研究社会变迁。</p><h3 id="社会关系说"><a href="#社会关系说" class="headerlink" title="社会关系说"></a>社会关系说</h3><p>社会的本质是什么？社会行为的本质是什么？最关键的是关系。人与人，人与组织，组织与组织的互动都建立着稳定的纽带联系，这些稳定的联系总和我们称之为“社会关系的结构”，也就是社会网络结构。人是社会关系的总和，人类的群体行为和个体行为是社会关系作用的产物。</p><h3 id="小结：从社会学角度关心当代社会问题"><a href="#小结：从社会学角度关心当代社会问题" class="headerlink" title="小结：从社会学角度关心当代社会问题"></a>小结：从社会学角度关心当代社会问题</h3><p>社会学的问题意识：<br>社会学的问题意识就是从群体视角、整体视角提出问题，然后从结构、关系、变迁等方面分析这些问题的框架，广泛观察，把握关键数据，遵循科学主义的原则，研究这些问题，得出结论。</p><p>分化问题：<br>整体性：改革开放以来社会不平等增加了还是降低了？为什么？<br>群体性：哪些人的生活改善了、进步了？哪些人困苦了、退步了？</p><p>整合问题：<br>整体性：社会道德水平和凝聚力正在提高还是降低？不管这个趋势怎么样为什么？<br>群体性：哪些群体道德水平和凝聚力在提高和下降？为什么？</p><h2 id="二、社会学的起源与发展"><a href="#二、社会学的起源与发展" class="headerlink" title="二、社会学的起源与发展"></a>二、社会学的起源与发展</h2><h3 id="社会学起源历史背景"><a href="#社会学起源历史背景" class="headerlink" title="社会学起源历史背景"></a>社会学起源历史背景</h3><p>动荡和探索的欧洲：18 世纪前后宗教改革、文艺复兴、对君主专制的反抗</p><p>英国工业革命：及其取代人力、工人阶级产生、资本主义的原始积累</p><p>法国大革命：现代思想、名族民主革命、传统向现代的转变</p><h3 id="马克思和韦伯的对比"><a href="#马克思和韦伯的对比" class="headerlink" title="马克思和韦伯的对比"></a>马克思和韦伯的对比</h3><p>马克思：所有目前我们知道的有文字记载的历史都是阶级社会，都是阶级历史。我们的阶级是生产关系占有的反映。占有生产资料的一方是一种阶级（资产阶级，有产阶级），不占有生产资料的一方是（无产阶级，工人阶级）。占有生产资料同时使用生产资料进行投资、生产并且剥削工人阶级的所创造的剩余价值，那你就是剥削阶级。</p><p>韦伯：社会地位（他人对你的评价，可能是基于你的生产资料的占有关系，你是所有者还是非所有者），还有其他人对你个人人格的认可和承认，或者是对你的职业的喜爱（声望级别）。</p><p>人们之间的权力关系（A 必须 听从 B 的指令去进行某种社会行为）</p><h3 id="小结：理论导向的实证社会科学"><a href="#小结：理论导向的实证社会科学" class="headerlink" title="小结：理论导向的实证社会科学"></a>小结：理论导向的实证社会科学</h3><p>提出事实假设，这个判断需要反复证明（想问题，究理论【研究现象和问题的本质特征和内在变动逻辑】，重证明）</p><p>理论假设的 4 种状态：</p><ol><li><p>互悖</p></li><li><p>并行（从不同的侧面去看待，但两者之间是没有矛盾的）  </p></li><li><p>互补（缺一不可，每一个假设都看到了问题的某一个方面） </p></li><li><p>互为条件（如果 A 假设不成立，那么 B 假设也不成立）</p></li></ol><h2 id="三、当代社会学的主要流派"><a href="#三、当代社会学的主要流派" class="headerlink" title="三、当代社会学的主要流派"></a>三、当代社会学的主要流派</h2><h3 id="功能论"><a href="#功能论" class="headerlink" title="功能论"></a>功能论</h3><p>整个社会就像一个有生命的机体，这个机体的各个部门都是为了维护这个机体的生存和延续而存在。功能论强调社会是有相互依存的各部分构成的整体系统，其中各个部门的存在都是为了维护社会的稳定。分化（功能分化，角色作用）和依赖（各个部分之间都是相互依赖的）是功能论的核心概念。</p><h3 id="冲突论"><a href="#冲突论" class="headerlink" title="冲突论"></a>冲突论</h3><p>社会结构之间充满了利益的分化和不平等，这些不平等带来了社会的冲突，从而促进了社会的发展。冲突在社会中普遍存在，且冲突是社会发展的原动力。</p><p>大的财团可能出现管理权（管权）和所有权（产权）分离，阶级关系更加复杂。</p><h3 id="互动论"><a href="#互动论" class="headerlink" title="互动论"></a>互动论</h3><p>任何社会制度，社会文化，社会结构等宏观层次的影响，都必须通过社会行动者的互动而发生。所以，不同场景下的社会互动及其行为影响机制，是社会学理论建构和理论解释的必要环节。</p><h3 id="关系论"><a href="#关系论" class="headerlink" title="关系论"></a>关系论</h3><p>人是社会关系的总和，人们的态度和行为，受其社会网络关系的制约。</p><h3 id="小结：多重理论视角问题"><a href="#小结：多重理论视角问题" class="headerlink" title="小结：多重理论视角问题"></a>小结：多重理论视角问题</h3><ol><li><p>不同的理论范式，给出不同的关于社会性质的判断。基于某个判断提出理论预设的前提假定。（要考虑多个理论视角的观点，用事实来印证哪一个观点在什么样的条件下是正确的）</p></li><li><p>在任何一个理论的前提假定下，注重多重的理论解释，提出相互区别的研究假设。</p></li><li><p>在同一个理论框架内，注重多重因果机制的研究，因为这些机制是解释人们行为和态度的关键。</p></li></ol><h2 id="四、社会学的研究方法"><a href="#四、社会学的研究方法" class="headerlink" title="四、社会学的研究方法"></a>四、社会学的研究方法</h2><h3 id="人文主义和科学主义的关系"><a href="#人文主义和科学主义的关系" class="headerlink" title="人文主义和科学主义的关系"></a>人文主义和科学主义的关系</h3><ul><li>人文主义：真、善、美 最终目的是人类社会的进步</li><li>科学主义：求真 科学的目的是探究真理，而不是价值判断</li></ul><h3 id="定性研究和定量研究的关系"><a href="#定性研究和定量研究的关系" class="headerlink" title="定性研究和定量研究的关系"></a>定性研究和定量研究的关系</h3><ul><li><p>定性：探讨发现理论，由个体到总体，从特殊向一般变化（归纳法）；重视现象和事实的北京，深入理解社会现象</p></li><li><p>定量：证明理论，从面来概括，向个体推论的，从一般到特殊（演绎法）；挖掘客观事实，强调现象间的因果关系</p></li></ul><p><a href="http://www.chinagss.org/" target="_blank" rel="noopener">中国综合社会调查 CGSS </a></p><h3 id="理论导向和政策导向的关系"><a href="#理论导向和政策导向的关系" class="headerlink" title="理论导向和政策导向的关系"></a>理论导向和政策导向的关系</h3><ul><li>理论导向：关心的是逻辑困惑，解决“为什么”的问题，研究思路是“想问题、究理论、重证明”</li><li>政策导向：关心的是现实困惑，解决“怎么办”的问题，其研究思路是“抓问题、摆事实、提对策”</li><li>双向导向：第一步，理论探究，把握本质问题。第二步，政策分析，从综合分析中提对策。</li></ul><h2 id="五、社会学与其他社会科学的关系"><a href="#五、社会学与其他社会科学的关系" class="headerlink" title="五、社会学与其他社会科学的关系"></a>五、社会学与其他社会科学的关系</h2><h3 id="与哲学的关系"><a href="#与哲学的关系" class="headerlink" title="与哲学的关系"></a>与哲学的关系</h3><p>社会学是从哲学中分化出来，逐步摆脱哲学的思辨。</p><ol><li>哲学是人文学科和社会科学的最高抽象。</li><li>社会学是一门解释性的社会科学，理论探索是其基础，所以学好社会学需要一定程度的概念抽象能力、理论思辨能力，也就是说，需要一定的哲学基础。</li><li>社会学的理论分析，或者采取归纳方式，或者采取演绎方式，都是基于逻辑学原理的。所以从事社会学研究，需要逻辑学知识。</li></ol><h3 id="与心理学的关系"><a href="#与心理学的关系" class="headerlink" title="与心理学的关系"></a>与心理学的关系</h3><p>社会心理学和心理学的交叉领域是社会心理学，心理学的社会心理学试图从人格结构求得对人类社会行为的解释，而社会学的社会心理学则通过群体因素来求得人们的社会互动方式、过程、机制等。</p><ul><li>社会行为和社会态度有心里学的基础。</li><li>社会心理学研究的是群里的现象以及对个体的影响。</li><li>心理学和社会心理学推行的实验法是建立因果关系模型的最佳方法。</li><li>从事社会学研究，需要向心理学和社会心理学学习相关知识和实验研究方法。</li></ul><h3 id="与经济学的关系"><a href="#与经济学的关系" class="headerlink" title="与经济学的关系"></a>与经济学的关系</h3><p>人们的经济行为不是孤立发生的，因为经济活动不但产生社会关系，而且是在这种关系中发生和发展的，经济交往的根本资源，如信息和信任，也是嵌于社会网络关系之中的。</p><ul><li>拥有一定的经济学知识，能更好的理解社会学理论。</li><li>经济和社会的关系，经济发展如何受文化、政治、社会的制约，是改革开发以来重大的现实问题。</li><li>信任问题、信息传播的社会制约问题、网络经济的行为模式问题、人情关系对于资源配置的正负效应问题，是重要的经济社会学问题，具有十分重要的理论和政策意义。</li></ul><h3 id="与政治学的关系"><a href="#与政治学的关系" class="headerlink" title="与政治学的关系"></a>与政治学的关系</h3><p>政治研究的对象是公共空间及其秩序，核心的研究对象是权利的产生、权利的分配、权利的使用、权利的合法性的过程。</p><ul><li>拥有一定的政治学知识，可以帮助理解社会学理论。</li><li>政治与社会的关系，特别是政治发展是如何受社会和文化的制约。</li><li>政府信任问题、制度信任问题、权利腐败问题，具有十分重要的政策意义。</li></ul><h2 id="六、学习社会学的意义"><a href="#六、学习社会学的意义" class="headerlink" title="六、学习社会学的意义"></a>六、学习社会学的意义</h2><ul><li>认识自我，适应社会</li><li>获得客观知识，掌握认知工具</li><li>认识规律，贡献社会</li><li>个体小我，群体大我</li></ul>]]></content>
      
      
      <categories>
          
          <category> 通识教育 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>郑伯克段于鄢</title>
      <link href="/2018/09/24/gu-wen-guan-zhi-zheng-bo-ke-duan-yu-yan/"/>
      <url>/2018/09/24/gu-wen-guan-zhi-zheng-bo-ke-duan-yu-yan/</url>
      
        <content type="html"><![CDATA[<h3 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h3><pre><code>    初，郑武公娶于申，曰武姜，生庄公及共叔段。庄公寤生，惊姜氏，故名曰寤生，遂恶之。爱共叔段，欲立之，亟请于武公，公弗许。    及庄公即位，为之请制。公曰：“制，岩邑也，虢叔死焉。他邑唯命。”请京，使居之，谓之京城大叔。祭仲曰：“都城过百雉，国之害也。先王之制：大都不过叁国之一，中五之一，小九之一。今京不度，非制也，君将不堪。” 公曰：“姜氏欲之，焉辟害？”对曰：“姜氏何厌之有！不如早为之所，无使滋蔓，蔓，难图也。蔓草犹不可除，况君之宠弟乎！”公曰：“多行不义必自毙。子姑待之。”    既而大叔命西鄙、北鄙贰于己。公子吕曰：“国不堪贰，君将若之何？欲于大叔，臣请事之，若弗与，则请除之，无生民心。”公曰：“无庸，将自及。”大叔又收贰以为己邑，至于廪延。子封曰：“可矣。厚将得众。”公曰：“不义不昵，厚将崩。”    大叔完聚，缮甲兵，具卒乘，将袭郑，夫人将启之。公闻其期，曰：“可矣！”命子封帅车二百乘以伐京。京叛大叔段。段入于鄢。公伐诸鄢。五月辛丑，大叔出奔共。    书曰：“郑伯克段于鄢。”段不弟，故不言“弟”。如二君，故曰“克”。称“郑伯”，讥笑教也，谓之郑志。不言“出奔”，难之也。    遂置姜氏于城颍而誓之曰：“不及黄泉，无相见也！”既而悔之。颍考叔为颍谷封人，闻之，有鲜于公。公赐之食，食舍肉，公问之，对曰：“小人有母，皆尝小人之食矣，未尝君之羹，请以遗之。”公曰：“尔有母遗，繄我独无！”颍考叔曰：“敢问何谓也？”公语之故，且告知悔。对曰：“君何患焉！若阙地及泉，遂而相见，其谁曰不然？”公从之。公入而赋：“大遂之中，其乐也融融。”姜出而赋：“大遂之外，其乐也泄泄。”遂为母子如初。</code></pre><h3 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h3><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> 文言文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 古文观止 </tag>
            
            <tag> 左传 </tag>
            
            <tag> 通识教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建 hexo 博客</title>
      <link href="/2018/09/24/hexo-bo-ke-da-jian/"/>
      <url>/2018/09/24/hexo-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<p>简单记录 github-page 搭建博客的步骤</p><h3 id="安装博客框架"><a href="#安装博客框架" class="headerlink" title="安装博客框架"></a>安装博客框架</h3><pre><code>## 安装 hexo$ npm install -g hexo-cli## 建站$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>关于 hexo 的大部分配置均可修改 <code>_config.yml</code> 完成</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener" title="hexo-theme-matery">hexo-theme-matery</a></p><p>按图索骥即可</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>安装 hexo-deployer-git</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><p>修改配置</p><pre><code>deploy:  type: git  repo: &lt;repository url&gt;  branch: [branch]  message: [message]</code></pre><pre><code>### 部署到远端$ hexo deploy</code></pre>]]></content>
      
      
      <categories>
          
          <category> 备忘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring 中的事件机制</title>
      <link href="/2018/09/08/spring-zhong-de-shi-jian-ji-zhi/"/>
      <url>/2018/09/08/spring-zhong-de-shi-jian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="spring-默认提供的系统事件"><a href="#spring-默认提供的系统事件" class="headerlink" title="spring 默认提供的系统事件"></a>spring 默认提供的系统事件</h4><p><img src="https://i.imgur.com/zlucVL0.png" alt=""></p><p>一般当容器启动后，我们需要加载某些资源或者执行操作，可以通过 <code>ContextRefreshedEvent</code> 完成。</p><p>示例:</p><pre><code class="java">public class ApplicationStartupListener implements ApplicationListener&lt;ContextStartedEvent&gt; {    @Override    public void onApplicationEvent(ContextStartedEvent event) {        // 可以拿到容器        ApplicationContext applicationContext = event.getApplicationContext();        // 在这里进行业务处理    }}</code></pre><p>启动时预先注册进容器:</p><pre><code class="java">AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext();app.register(Config8.class);app.addApplicationListener(new ApplicationStartupListener()); //注意这里app.refresh();app.start();app.close();</code></pre><p>在 <code>non-web</code> 的 <code>spring</code> 中注册可以采用这种方式，方便让开发者清楚的知道现在有哪些事件监听器是起作用的。实际上，只需要将事件监听器注册进 <code>spring</code> 容器即可生效。于此同时可以发现 <code>EventObject</code> 有非常多的事件实现，具体使用时可以查看有没有符合心意的。</p><h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><p>如上，我们看到名为 <code>PayloadApplicationEvent&lt;T&gt;</code> 的事件接口，可以利用此接口来实现自己的自定义事件。</p><pre><code class="java">public class MessageListener implements ApplicationListener&lt;PayloadApplicationEvent&lt;Message&gt;&gt; {    @Override    public void onApplicationEvent(PayloadApplicationEvent&lt;Message&gt; event) {        System.out.println(&quot;接收到事件：&quot; + event.getPayload().getMessage());    }}</code></pre><p>发布事件:</p><pre><code class="java">AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext();app.register(Config8.class);app.addApplicationListener(new MessageListener());app.refresh();app.start();app.publishEvent(new Message(&quot;消息&quot;));app.close();</code></pre><p>这里也是同样的道理，只需要注册进容器即可。</p><h5 id="使用-EventListener-注解"><a href="#使用-EventListener-注解" class="headerlink" title="使用 @EventListener 注解"></a>使用 @EventListener 注解</h5><p>上面的用法是实现了接口，<code>spring</code> 也提供了注解的支持。</p><pre><code class="java">@Servicepublic class EmailService {    @EventListener    public void send(String address) {        System.out.println(&quot;发送邮件 -&gt; &quot; + address);    }}</code></pre><pre><code class="java">AnnotationConfigApplicationContext app = new AnnotationConfigApplicationContext();app.register(Config8.class);app.addApplicationListener(new ApplicationStartupListener());app.refresh();app.start();app.publishEvent(&quot;pleuvior@foxmail.com&quot;);app.close();</code></pre><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><img src="https://i.imgur.com/70POWGo.png" alt=""></p><ol><li>初始化事件分发器</li></ol><p><img src="https://i.imgur.com/wE3jGAj.png" alt=""></p><p>新建一个简单的事件广播器 <code>SimpleApplicationEventMulticaster</code> ，注意此处的 <code>taskExecutor</code> 为 <code>null</code></p><p>这里我们当然也可以自己制造一个。</p><pre><code class="java">@Bean(name = AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)public ApplicationEventMulticaster initApplicationEventMulticaster(BeanFactory beanFactory) {    SimpleApplicationEventMulticaster applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);    ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;事件处理线程-%d&quot;).build();    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(Runtime.getRuntime().availableProcessors() * 2,            200, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(128), threadFactory);    //threadPoolExecutor.prestartAllCoreThreads();    applicationEventMulticaster.setTaskExecutor(threadPoolExecutor);    applicationEventMulticaster.setErrorHandler(new ErrorHandler() {        @Override        public void handleError(Throwable t) {                System.out.println(&quot;出错了&quot;);                t.printStackTrace();        }    });    return applicationEventMulticaster;}</code></pre><ol start="2"><li>注册监听器</li></ol><p>先将静态的监听器注册进来，即实现了 <code>ApplicationListener</code> 接口的。</p><ol start="3"><li>容器启动</li></ol><p><img src="https://i.imgur.com/lbuf4Wz.png" alt=""></p><p>可以看到 <code>start</code> 和 <code>stop</code> 时分别发布了两个事件。点进去看到:</p><p><img src="https://i.imgur.com/h96JtFh.png" alt=""></p><p>当我们发布的内容没有实现 <code>ApplicationEvent</code> 接口，则创建一个 <code>PayloadApplicationEvent</code> 类型的事件。</p><p><img src="https://i.imgur.com/T7vG7MU.png" alt=""></p><p><img src="https://i.imgur.com/gYD6Wk3.png" alt=""></p><p>如下标红的两处，即是找到了对应的监听器。其中第一处的 <code>defaultRetrieve.applicationListeners</code>的值是下图执行时添加的。可以注意到，这里的事件类型匹配是根据参数类型，所以监听器一旦出现多个形参是基本类型的方法，会发现这些事件都会被广播一次。</p><p>下图是给每个被 @EventListener 标记的方法创建一个新的事件监听器，并添加到广播器中:</p><p><img src="https://i.imgur.com/zgjMDsU.png" alt=""></p><p><img src="https://i.imgur.com/JbOqxZr.png" alt=""></p><p>这里 <code>supportEvent</code> 方法点进去看，会发现有判断当前监听器的类型，当我们的监听器是使用注解创建时类型为 <code>ApplicationListenerMethodAdapter</code>，实现接口的则为 <code>GenericApplicationListenerAdapter</code>。 这两种判断有些区别，如果是 <code>GenericApplicationListenerAdapter</code> 会去检查当前发布的事件对象是否为监听器的实现，它里面不会去判断 <code>payload</code> 的继承关系。而 <code>ApplicationListenerMethodAdapter</code> 则先判断是否为实现（基本上不会），它会再次判断 <code>payload</code> 的继承关系。这样就会出现子类继承父类，发布父类事件，子类父类事件都执行的问题。</p><p>发布事件的代码</p><pre><code class="java">public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));    for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {        Executor executor = getTaskExecutor();        if (executor != null) {        // 所以只要我们设置了线程池则可以以异步的形式执行            executor.execute(() -&gt; invokeListener(listener, event));        }        else {            invokeListener(listener, event);        }    }}// 同样可以使用错误处理器protected void invokeListener(ApplicationListener&lt;?&gt; listener, ApplicationEvent event) {        ErrorHandler errorHandler = getErrorHandler();        if (errorHandler != null) {            try {                doInvokeListener(listener, event);            }            catch (Throwable err) {                errorHandler.handleError(err);            }        }        else {            doInvokeListener(listener, event);        }    }</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，整个流程已经分析完毕。使用默认的事件机制，可以实现编译期的解耦，但是不能实现运行时解耦。所以可以提供线程池，让广播时新启动线程，这样则达到了单应用中合理的解耦。如果项目中某行代码不想在声明式事务中执行，则可以使用此种方式。而它也比编程时事务的代码复杂度以及合理性更胜一筹。建议使用实现接口的形式，这样不同的业务代码是隔离的。并且不会出现父子通知的问题。</p><p>代码: <a href="https://github.com/pleuvoir/reference-samples/blob/master/spring-annotation-based-example/src/main/java/io/github/pleuvoir/chapter08/Config8.java" target="_blank" rel="noopener" title="spring 事件">spring 事件</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端推送技术调研</title>
      <link href="/2018/09/01/fu-wu-duan-tui-song-ji-zhu/"/>
      <url>/2018/09/01/fu-wu-duan-tui-song-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端推送技术"><a href="#服务端推送技术" class="headerlink" title="服务端推送技术"></a>服务端推送技术</h2><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><ul><li>服务端基本不用改造</li><li>服务器沉重压力和资源的浪费(消耗带宽)</li><li>数据同步不及时</li></ul><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>基于 AJAX 的长轮询（long-polling） 方式；基于Servlet3 异步支持 -》Spring 的 DefferedResult</p><ul><li>基于 HTTP 长连接、无须在浏览器端安装插件，当 server 没有数据时抓住 client 的请求不放，直到有数据时再返回给 client，当 client 处理完业务后马上在发起第二次请求。每次断开会存在重新连接（重新握手），这是一点缺点。最大的问题是连接数不够用 。所以后端一般时有一个线程池去处理这些任务，这些不会去占用 tomcat 的连接数（tomcat 连接一般不超过 1000）。这种就是 servlet 的异步任务，缺点是代码实现相当麻烦。在 spring 下，为我们提供了封装好的 <code>DefferedResult</code>更为方便。</li></ul><p>SSE</p><ul><li>SSE （event-stream）也是长轮询，不过和上面的区别在于它会抓住不放，响应给客户端的不是数据包，而是数据流。缺点：不是所有的浏览器都支持。<code>IE</code> 系列的浏览器不支持，如果不考虑浏览器兼容问题，可以选择。折中的办法是需要做退化，判断浏览器是否支持，如果支持则使用。否则退化为 AJAX 长轮询或者短轮询，一个设计良好的程序必须注意这一点。同时 <code>SSE</code> 不支持二进制，只支持文本传输。优点：轻量，简单，提供自动的短线重连机制。而 <code>Websocket</code> 需要自行实现。同时此协议构建在 <code>HTTP</code> 之上。<code>spring</code> 同样也提供了支持，类的名字 <code>SseEmitter</code>，但是其实并没有比原生的简单多少。</li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>支持二进制、支持流</p><p><code>WebSocket</code> 版本有很多，第一次建立连接一定会发送 <code>HTTP</code> 请求，请求报文中会发送 <code>Upgarde:websocket</code> 要求之后的连接需要升级为 <code>WebSocket</code> 协议。同时 <code>Connection:keep-alive,Upgrade</code>。服务端会进行响应 <code>Upgrade:websocket</code> 标识升级成功，之后的请求会使用 <code>WebSocket</code> 进行通信。</p><p>而 <code>WebSocket</code> 只是一个协议，是一个纸面上的东西。它有两种实现，在 <code>HTML5</code> 中有 <code>WebSocket</code> 的 api，另一个是 <code>WebSocket</code> 子协议 <code>STOMP(简单流文本定向消息协议)</code>，前身 <code>TTMP</code> 协议是为消息中间设计的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><a href="https://github.com/pleuvoir/reference-samples/tree/master/comet-sample" target="_blank" rel="noopener">服务器推送技术</a><br><a href="https://github.com/pleuvoir/reference-samples/tree/master/stomp-sample" target="_blank" rel="noopener">基于 stomp 的聊天室</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雨</title>
      <link href="/2018/07/07/yu/"/>
      <url>/2018/07/07/yu/</url>
      
        <content type="html"><![CDATA[<p>傍晚时分，突然下起了大雨，好在是没有起风，看这雨势丝毫没有黯淡下来的架势，我心知今日看房的计划只能作罢，便也不在急躁。待到雨势稍弱，仰仗着卢先生那把逼仄的小伞，便在雨中游走了起来。平日用来踩水坑的鞋自然派上了用场，只是为了配合他人，也装作急切的样子小跑起来。公交似乎知道了人们的窘迫，也是三步并作两步，及时接纳了我们。也许是车内外恍若隔世，或者是不那么新鲜的空气，一路的旅途略感沉闷，闲思杂虑也不由得滋生起来。惊醒之时已是终点，窗外的雨也不争气的停了，心中难免生起一丝寥落。虽然平日衣服洗的极为勤快，惭愧得很，我的鞋却经常雨露未沾。便起了一个念想，回到家中，趁着诚意还在匆忙的宠幸了一番。也许是由于天气的缘故，唤起了我往世的记忆，山顶洞人雨天好眠，我也是。醒来时已是凌晨，心头的空落落在此刻散播开来。平日里诚心诚意的时间不多，只好吝啬的计算着自己可怜的时间和精力，不肯一分一秒被裹挟在人群里，涌向僵尸行军似的无望远方。</p><p>隐约雷鸣，阴霾天空，但盼风雨来，能留你在此。</p>]]></content>
      
      
      <categories>
          
          <category> 闲思杂虑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现一个LRUCache</title>
      <link href="/2018/06/19/ru-he-shi-xian-yi-ge-lrucache/"/>
      <url>/2018/06/19/ru-he-shi-xian-yi-ge-lrucache/</url>
      
        <content type="html"><![CDATA[<p>如何实现一个LRUCache</p><h2 id="基于链表LRUCache实现"><a href="#基于链表LRUCache实现" class="headerlink" title="基于链表LRUCache实现"></a>基于链表LRUCache实现</h2><p>思路：</p><p>维护一个固定大小的单向链表，保证热数据永远在最后</p><p>1.新增的元素增加到链表的末尾，如果空间不足则删除第一个元素节点后再增加</p><p>2.修改的元素移动到末尾，并删除原节点</p><p>3.查找时如果之前已经有这个元素，则移动到末尾</p><p>具体的实现可参考笔者以前写的<a href="https://github.com/pleuvoir/Data-Structure-and-Algorithms/blob/master/source/data-structure-and-algorithms/src/main/java/io/github/pleuvoir/datasructure/linkedlist/Lru.java" target="_blank" rel="noopener">单向链表实现</a></p><h2 id="基于LinkedHashMap的实现"><a href="#基于LinkedHashMap的实现" class="headerlink" title="基于LinkedHashMap的实现"></a>基于LinkedHashMap的实现</h2><p>其实 <code>LinkedHashMap</code> 本身已经为我们的实现铺好了路。</p><pre><code class="java">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}</code></pre><p>注释：</p><pre><code class="java"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this map should remove its eldest entry. * This method is invoked by &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;putAll&lt;/tt&gt; after * inserting a new entry into the map.  It provides the implementor * with the opportunity to remove the eldest entry each time a new one * is added.  This is useful if the map represents a cache: it allows * the map to reduce memory consumption by deleting stale entries. * * &lt;p&gt;Sample use: this override will allow the map to grow up to 100 * entries and then delete the eldest entry each time a new entry is * added, maintaining a steady state of 100 entries. * &lt;pre&gt; *     private static final int MAX_ENTRIES = 100; * *     protected boolean removeEldestEntry(Map.Entry eldest) { *        return size() &amp;gt; MAX_ENTRIES; *     } * &lt;/pre&gt;</code></pre><p>该方法的意思是当返回true时，将从容器中移除最老的元素。该方法会在调用<code>put</code>和<code>putAll</code>时触发。</p><p>其中还有一个关键点即访问顺序：</p><pre><code class="java">/** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. * */final boolean accessOrder;</code></pre><p>如果<code>accessOrder</code>为true的话(这个值默认是false)，每次访问会把元素放在链表后面，举个例子：</p><pre><code class="java">@Test public void fun2() throws Exception {     LinkedHashMap&lt;String, String&gt; accessOrderTrue = new LinkedHashMap&lt;&gt;(16, 0.75f, true);     accessOrderTrue.put(&quot;1&quot;,&quot;1&quot;);     accessOrderTrue.put(&quot;2&quot;,&quot;2&quot;);    accessOrderTrue.put(&quot;3&quot;,&quot;3&quot;);     accessOrderTrue.put(&quot;4&quot;,&quot;4&quot;);     System.out.println(&quot;acessOrderTure&quot;+accessOrderTrue);     accessOrderTrue.get(&quot;2&quot;);     accessOrderTrue.get(&quot;3&quot;);     System.out.println(&quot;获取了数据&quot;+accessOrderTrue); } //控制台输出 acessOrderTure{1=1, 2=2, 3=3, 4=4} 获取了数据{1=1, 4=4, 2=2, 3=3}</code></pre><p>基于如上的两种特性，我们就可以快速的实现自己的LRUCache。</p><pre><code class="java">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {    private static final long serialVersionUID = -5167631809472116969L;    private static final float DEFAULT_LOAD_FACTOR = 0.75f;    private static final int DEFAULT_MAX_CAPACITY = 1000;    // 容器最大缓存量    private final Lock lock = new ReentrantLock();    private volatile int maxCapacity;    public LRUCache() {        this(DEFAULT_MAX_CAPACITY);    }    public LRUCache(int maxCapacity) {        super(16, DEFAULT_LOAD_FACTOR, true);        this.maxCapacity = maxCapacity;    }    @Override    protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {        return size() &gt; maxCapacity;    }    @Override    public boolean containsKey(Object key) {        lock.lock();        try {            return super.containsKey(key);        } finally {            lock.unlock();        }    }    @Override    public V get(Object key) {        lock.lock();        try {            return super.get(key);        } finally {            lock.unlock();        }    }    @Override    public V put(K key, V value) {        lock.lock();        try {            return super.put(key, value);        } finally {            lock.unlock();        }    }    @Override    public V remove(Object key) {        lock.lock();        try {            return super.remove(key);        } finally {            lock.unlock();        }    }    @Override    public int size() {        lock.lock();        try {            return super.size();        } finally {            lock.unlock();        }    }    @Override    public void clear() {        lock.lock();        try {            super.clear();        } finally {            lock.unlock();        }    }    public int getMaxCapacity() {        return maxCapacity;    }    public void setMaxCapacity(int maxCapacity) {        this.maxCapacity = maxCapacity;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曾国藩《挺经》笔记</title>
      <link href="/2018/05/28/ceng-guo-fan-ting-jing-bi-ji/"/>
      <url>/2018/05/28/ceng-guo-fan-ting-jing-bi-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="逆境挺拔"><a href="#逆境挺拔" class="headerlink" title="逆境挺拔"></a>逆境挺拔</h3><ol><li>以心换心，推己及人，正确处理矛盾。</li><li>宽以待人，做事留有余地。</li><li>站在别人的立场上看问题，淡化一个“我”字，会有比较客观的认识。</li></ol><h3 id="自立自强"><a href="#自立自强" class="headerlink" title="自立自强"></a>自立自强</h3><ol><li>重视教育</li><li>弱国欲自强，只有靠踏实苦干，装模作样无用。</li></ol><h3 id="立志有恒"><a href="#立志有恒" class="headerlink" title="立志有恒"></a>立志有恒</h3><ol><li>欲成就大事，须先立坚卓之志。</li><li>愚人安于现状，贤人常思进取，这个作为区分贤愚的标准。</li><li>人有志，则不甘为下流。</li></ol><h3 id="大事担当"><a href="#大事担当" class="headerlink" title="大事担当"></a>大事担当</h3><ol><li>男儿欲自立于世，必须有倔强之气。</li><li>倔强必须以明白事理为前提，否则则是刚愎自用。</li><li>高明源于天分，精明源于学问。</li></ol><h3 id="躬身入局"><a href="#躬身入局" class="headerlink" title="躬身入局"></a>躬身入局</h3><ol><li>许多极苦难之事，只要挺一挺，也就过去了。</li><li>“打脱牙和血吞”的坚韧精神（韧性），可助人成大事。</li><li>欲成大事，先须战胜自我。</li></ol><h3 id="血性之刚"><a href="#血性之刚" class="headerlink" title="血性之刚"></a>血性之刚</h3><ol><li>盛时续作衰时想，上场预留下场路。</li><li>物极必反，花未开全月未满月</li></ol><blockquote><p>花未开全月未满的字面意思是：鲜花开放但还没有全部盛开，月亮盈圆但还未到十五，这时候，我们对美好事物充满了期待，是最好的时候。如果花还未含苞，月还没现月牙，美好的事务还遥遥无期，或者花已盛开，月已全满，接下来的就是逐步凋零和亏缺，就打了折扣了。所以，这句话体现了曾国藩的人生哲学，就是物极必反，任何事物都要留有余地，不要追求极致。</p></blockquote><h3 id="磨砺刚操"><a href="#磨砺刚操" class="headerlink" title="磨砺刚操"></a>磨砺刚操</h3><p>识人用人，研究如何识才育才用才的艺术。</p><h3 id="勤勉忍耐"><a href="#勤勉忍耐" class="headerlink" title="勤勉忍耐"></a>勤勉忍耐</h3><p>勤劳，从日常小事做起。千古之圣贤豪杰，不外一勤字。</p><h3 id="内省不疚"><a href="#内省不疚" class="headerlink" title="内省不疚"></a>内省不疚</h3><ol><li>君子要内修身心，才华不逞，才有任重道远，担当大事的力量。</li><li>修己之道，须终生研习，则终生取用不尽。</li></ol><h3 id="戒堕戒贪"><a href="#戒堕戒贪" class="headerlink" title="戒堕戒贪"></a>戒堕戒贪</h3><ol><li>家败家兴，全靠子弟贤与不贤。</li><li>遗财与子孙，子孙若贤，无所用之；子孙不肖。徒增其祸；子孙无能，势必为人所夺。</li></ol><h3 id="崇俭尚廉"><a href="#崇俭尚廉" class="headerlink" title="崇俭尚廉"></a>崇俭尚廉</h3><p>富贵常履危机，廉俭可以自保。</p><h3 id="规模宏远"><a href="#规模宏远" class="headerlink" title="规模宏远"></a>规模宏远</h3><ol><li>谨言慎行，不致为小人陷害。危身奉上，方可去上司猜疑。</li><li>人臣难当，下级难做，为官者不可不深思而善处。</li><li>看破功名权势，名利两淡，“因其不争，故天下莫能与之争”，如此或可保身全命。</li></ol><h3 id="困勉变化"><a href="#困勉变化" class="headerlink" title="困勉变化"></a>困勉变化</h3><ol><li>读书可改变人的骨相，变化气质，进而改变人的命运。</li><li>但是仅有学问是不够的，博学之人更宜注重实际，注重实践。</li><li>学问不是装饰品，学以致用，方显示出学问的价值。</li></ol><blockquote><p>看生书宜求速，不多阅则太陋。（看生书的时候要讲求速度，这样才能在有限的时间里阅读更多的书，才不会因为读书少显得很低俗。）<br>温旧书宜求熟，不背诵则易忘。（看旧书的时候要讲求熟练认真，最好是时常背诵，这样才不至于看完就忘了。）<br>作文宜苦思，不善作则如人之哑不能言、马之跛不能行（作文章要有自己的见解、自己的思想，要善于写作，不善于写作就像人不能说话、马不能走路一样。“思”字对应的是“作文”，强调的是要深入思考，表达自己的见解和主张。经常写文章，可以很好的锻炼自己的逻辑思维能力，也可以是自己原有的知识积累得到运用，是读书治学的重要方法。）</p></blockquote><p>读书的主要目的是立德，至于技能之事则是次要。</p><p>注意读书的时间分配。</p><p>读书第一要有志，有志之人才能不甘于人下；须知学问无尽，不可自满，做井底之蛙；第三需要有恒心。此三者缺一不可。</p><p>读书要专一，一部未完不换下一部。读书要有耐心。看不懂过段时间再来看。</p><h3 id="去痛生新"><a href="#去痛生新" class="headerlink" title="去痛生新"></a>去痛生新</h3><ol><li>峻法、任政，均为施政治国手段，无所谓优劣，唯在恰当用之而已。</li><li>严刑峻法，有时可收杀一儆百的效果，只要对大局有利，亦无可非议。</li><li>峻法乃人治时期产物，法治时期应严格依法办事，法律不可有太大随意性。</li></ol><h3 id="内圣外王"><a href="#内圣外王" class="headerlink" title="内圣外王"></a>内圣外王</h3><p>人立于天地间，免不了友挫折，但心不灰意不冷，才指望大事有济。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与自我</title>
      <link href="/2018/05/27/wo-yu-zi-wo/"/>
      <url>/2018/05/27/wo-yu-zi-wo/</url>
      
        <content type="html"><![CDATA[<h2 id="我与自我"><a href="#我与自我" class="headerlink" title="我与自我"></a>我与自我</h2><p>话题引入：「我反思自我」  </p><h3 id="四重根体系"><a href="#四重根体系" class="headerlink" title="四重根体系"></a>四重根体系</h3><p>叔本华哲学理论  </p><p>表象都属于四重根体系（需要了解一下主体和客体在理论中的具体含义）  </p><ol><li>人（认识主体）：主体意识、感性、理性、悟性  </li><li>关系：动机率、存在率、因果律、认识律  </li><li>世界（客体）：主体意志、时空、物质、概念  </li></ol><h3 id="主体与客体的区分"><a href="#主体与客体的区分" class="headerlink" title="主体与客体的区分"></a>主体与客体的区分</h3><p>显然，这里的「我」指的就是认识主体了，自我则作为客体。「我」和「自我」之间是存在主被动关系的。「我」按照叔本华四重根理论则指的的主体意识、感性、理性以及悟性；「自我」从字面意义上理解更倾向于一种精神载体，作为被思考的对象，既然是对象则一定是表象，表象都属于四重根体系。除去关系与人，「自我」只能是主体意志了，因为时空、物质、概念和「自我」完全不沾边。  </p><p>因此，所谓我就是指认识主体即：自我意识、感性、悟性、理性。而自我则是指：主体意志。所以「我反思自我」是什么意思？  </p><p>「认识主体」反思「主体意志」  </p><h4 id="认识主体"><a href="#认识主体" class="headerlink" title="认识主体"></a>认识主体</h4><p>下面来讲一下「认识主体」的子类，即：自我意识、感性、悟性、理性。  </p><p>自我意识，实际上自我意识所做的事情特别简单，就是单纯的检测主体意志的状态。当主体意志的状态发生变化时，会直接影响到自我意识的变化，这种变化也就是情绪。所以，人的情绪实际上只是主体意志发生变化以后的直接体现。有时候我们莫名其妙感到消极，这种情绪完全不是自己控制的，而只是自身主体意志的一种传达。主体意志受到影响最简明的体现就是生病。人，一旦生病，情绪即会变得糟糕，当然这种物理状态的感知带来的主体意志变化也会从其他方面体现。  </p><p>感性：一般说感性，我们联想到的名词都是内心细腻，遇到挫折或者打击以后情绪波动的比较明显。如果这样说，那么感性等于情绪吗？不是的，上面已经提及情绪只是主体意志波动以后带来的提示或者说是警告。其实，人的感性又划分为外在和内在。外在即指的是五官感知，内在指的是身体器官物理性变化带来的身体体验，最简单的例子就是心痛，伤心之时的感觉很大可能就是心肌缺氧带来的（疏肝解郁胶囊）。那么又有一个问题接踵而至，这种内感官体验会影响到主体意志，而主体意志的改变又会通过主体意识的改变（情绪）体现出来。所有，这也就解释了为什么大家会称情绪波动比较的大人较为感性。但是请记住两者并非一物。  </p><p>理性：不管我们承认不承认，世界其实是有两个的。一个是现实世界，另一个是假想世界。现实世界遵循因果律，而假象世界则遵循的是逻辑。我们企图抽象现实世界表象映射到假想世界。在这个过程中不得从中定义了很多概念便于更好的理解现实世界。本质上我们的理性是是无法脱离现实，理性的活动过程即产生了思维，而思维是存在于大脑中的。所以，理性是依托于内在而又离不开外在的。然后，大量的分析判断、综合判断以及前天综合判断都通过理性输入到我们的大脑中。我们通过大量的学习，妄想依靠这些经验指导并确信自己可以实际使用这些经验。以为理性可以把握主体意志，于是就总是充分的去想，去反思，或者通过阅读某些书籍和伦理的教条，通过感觉自己认同这些观念，认同书中主人公的做法，从而也确定自己的主体意志也是这样的。其实不是，我们的理性思考已经难以脱离“普世价值观”，判断如果是经过理性思考的，那么一定会和主体意志有差异。你是不是这样的人，只有发生了那一刻才知道。这也正是读过了很多书却过不好这一生的辅证。  </p><p>悟性：悟性所对应的因果律以及它的三种高级模式（因果，刺激，动机），才直接决定你的行为。感性是不靠谱的，理性也是不靠谱的，想要认识主体意志，也就是这个自我，你需要的是悟性，是实实在在的行动，你的行动，才真正靠谱的说明了你是什么样的人。  </p><p>从这里我们就可以发现，主体意志是通过行动才能清晰的表现出来的，而感性和理性的认识只是针对我的行为所获得的表象在大脑中的反应罢了，这些表象随时会因为思维，想象力，记忆而形变，变得不真实，尤其人还最喜欢自我欺骗和不敢面对真实的自己，那么这种形变就会更加厉害。但对于真正的想认识自我的人来说，只有在你做出行为的那一刻，你的自我才是最为清晰的，那个自我才是你真正的确定了的肯定是属于你的自我。  </p><h4 id="主体意志"><a href="#主体意志" class="headerlink" title="主体意志"></a>主体意志</h4><p>主体意志（需要了解叔本华四重根理论）  </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>「我反思自我」，这种反思应该是对自身行为的源头主体意志的反思，而不是做出行为是否符合普世价值观以及伦理，否则只会陷入到我为什么会是这样做的泥潭中。悟性决定了你的行为，你的行为可以作为一个靠谱的依据来体现你的主体意志。至此「知行合一」的含义也就清晰明了了，你的行为和你的良知是一体的，良知决定了行为，而不是先有的良知才有的行为。一个人说什么并不能代表他的本体，而要看他做了什么。如若突发情况下他自己做出的言行令自己无法接受，不承认自己是那样的人，我们也应当理解，因为他自己可能不知道自己是那样的人，这样我们也就释怀了。对于生活中一些自己无法确定的问题，非得交给时间也是这样的道理，毕竟感性和理性这些表象会变得不真实。所有，平时对自己的行为进行观察，慢慢的明确自己真实的样子，去私欲留真理，慎独可能是我们最好的修习方式了。</p>]]></content>
      
      
      <categories>
          
          <category> 闲思杂虑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【源码分析】dubbo的SPI</title>
      <link href="/2018/04/19/yuan-ma-fen-xi-dubbo-de-spi/"/>
      <url>/2018/04/19/yuan-ma-fen-xi-dubbo-de-spi/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><p>SPI全称为（Service Provider Interface），是JDK提供的一种服务发现机制。一般常用于开发者对框架的扩展。具体使用是在Jar包的<code>META-INF/services</code> 目录下新建一个无格式文件（文件格式为必须UTF-8），文件名称为接口的全限定名，文件内容可以有多行，每一行都是该接口具体实现类的全限定类名。在JAVA中这样获取实现类：</p><pre><code class="java">ServiceLoader&lt;DynamicConfig&gt; factories = ServiceLoader.load(DynamicConfig.class);    for (DynamicConfig dynamicConfig : factories) {        System.out.println(dynamicConfig);    }</code></pre><p>需要注意的是，实现类必须提供默认的构造函数，否则无法实例化。</p><p>具体参考<a href="https://docs.oracle.com/javase/1.5.0/docs/guide/jar/jar.html#Service%20Provider" target="_blank" rel="noopener">Service Provider</a></p><h2 id="dubbo对SPI的扩展"><a href="#dubbo对SPI的扩展" class="headerlink" title="dubbo对SPI的扩展"></a>dubbo对SPI的扩展</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>dubbo也用了SPI思想，不过没有用JDK的SPI机制，自己实现了一套。看看官方文档的介绍：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p><p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p><p>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。<br>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 getName() 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户<br>执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。<br>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</p><p>约定：<br>在扩展类的 jar 包内，放置扩展点配置文件 META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。</p><p>示例：<br>以扩展 Dubbo 的协议为例，在协议的实现 jar 包内放置文本文件：META-INF/dubbo/org.apache.dubbo.rpc.Protocol，内容为：</p><p>xxx=com.alibaba.xxx.XxxProtocol<br>实现类内容：</p><p>package com.alibaba.xxx;</p><p>import org.apache.dubbo.rpc.Protocol;</p><p>public class XxxProtocol implements Protocol {<br>    // …<br>}</p><p>配置模块中的配置</p><p>Dubbo 配置模块中，扩展点均有对应配置属性或标签，通过配置指定使用哪个扩展实现。比如：<br>&lt;dubbo:protocol name=”xxx” /&gt;</p></blockquote><p><code>Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code></p><p><code>Protocol</code> 接口，<code>Dubbo</code> 要判断一下，在系统运行的时候，应该选用这个 <code>Protocol</code> 接口的哪个实现类来实例化对象来使用呢？</p><p>微内核，可插拔，大量的组件，<code>Protocol</code>负责rpc调用的东西，你可以实现自己的rpc调用组件，实现<code>Protocol</code>接口，给自己的一个实现类即可。</p><p>这行代码就是dubbo里大量使用的，就是对很多组件，都是保留一个接口和多个实现，然后在系统运行的时候动态根据配置去找到对应的实现类。如果你没配置，那就走默认的实现好了，没问题。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>dubbo的SPI主要有以下几种特性：</p><ul><li>支持 <code>key-value pair</code> 形式配置的扩展式JDK SPI</li><li>扩展点自动包装</li><li>扩展点自动装配</li><li>扩展点自适应</li><li>扩展点自动激活</li></ul><p>1）支持 <code>key-value pair</code> 形式配置的扩展式JDK SPI？</p><p>什么意思，就是以K-V的形式保存实现类，以 <code>Protocol</code> 接口举例：</p><pre><code class="java">@SPI(&quot;dubbo&quot;)  // 表示这个注解支持SPI扩展，dubbo做为key去配置文件找对应实现public interface Protocol {      int getDefaultPort();      @Adaptive      &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;      @Adaptive      &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;      void destroy();  } </code></pre><p>在dubbo自己的jar里，在<code>/META_INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol</code>文件中：</p><pre><code class="java">dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocolhttp=com.alibaba.dubbo.rpc.protocol.http.HttpProtocolhessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol</code></pre><p><code>@SPI(&quot;dubbo&quot;)</code>说的是，通过SPI机制来提供实现类，实现类是通过dubbo作为默认key去配置文件里找到的，配置文件名称与接口全限定名一样的，通过dubbo作为key可以找到默认的实现了就是com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol。</p><p>dubbo的默认网络通信协议，就是dubbo协议，用的DubboProtocol</p><p>2）扩展点自动包装？</p><p>当dubbo发现我们某个扩展点的实现类拥有一个拷贝构造函数时，变会认为这个类是包装类。什么是拷贝构造函数，如下：</p><pre><code class="java">package com.alibaba.xxx;import org.apache.dubbo.rpc.Protocol;public class XxxProtocolWrapper implements Protocol {    Protocol impl;    public XxxProtocolWrapper(Protocol protocol) { // 我是拷贝构造函数         impl = protocol;     }    // 接口方法做一个操作后，再调用extension的方法    public void refer() {        //... 一些操作        impl.refer();        // ... 一些操作    }    // ...}</code></pre><p><code>XxxProtocolWrapper</code>类实现了<code>Protocol</code>接口，并且构造方法入参为 <code>Protocol</code>，即可认为是包装类。</p><p>3） 扩展点自动装配？</p><p>这个功能类似于Spring的IOC，具体机制是当dubbo加载扩展点时，发现这个类中的set方法是另外一个扩展点，便会获取并自动注入。如下：</p><p>示例：有两个为扩展点 CarMaker（造车者）、WheelMaker (造轮者)</p><pre><code class="java">public interface CarMaker {    Car makeCar();}public interface WheelMaker {    Wheel makeWheel();}</code></pre><p>CarMaker 的一个实现类：</p><pre><code class="java">public class RaceCarMaker implements CarMaker {    WheelMaker wheelMaker;    public setWheelMaker(WheelMaker wheelMaker) {  //此方法会被dubbo发现并尝试注入WheelMaker的扩展点实现        this.wheelMaker = wheelMaker;    }    public Car makeCar() {        // ...        Wheel wheel = wheelMaker.makeWheel();        // ...        return new RaceCar(wheel, ...);    }}</code></pre><p>这里带来另一个问题，ExtensionLoader 要注入依赖扩展点时，如何决定要注入依赖扩展点的哪个实现。在这个示例中，即是在多个WheelMaker 的实现中要注入哪个。</p><p>这个问题在下面一点扩展点自适应中说明。</p><p>4） 扩展点自适应？</p><p>dubbo的扩展点依赖于统一抽象模型URL，在所有的扩展点中均有此参数，如下：</p><pre><code class="java">public interface CarMaker {    Car makeCar(URL url);}public interface WheelMaker {     @Adaptive({&quot;circular&quot;, &quot;square&quot;})    Wheel makeWheel(URL url);}</code></pre><p>实现类：</p><pre><code class="java">public class RaceCarMaker implements CarMaker {    WheelMaker wheelMaker;    public setWheelMaker(WheelMaker wheelMaker) {        this.wheelMaker = wheelMaker;    }    public Car makeCar(URL url) {        // ...        Wheel wheel = wheelMaker.makeWheel(url);        // ...        return new RaceCar(wheel, ...);    }}</code></pre><p>当上面的代码执行到<code>wheelMaker.makeWheel(url);</code>时，会从url中提取指定的key找到对应的实现类，这个key是设置在扩展点接口方法注解上的。</p><p>makeWheel()方法，Adaptive实现先查找circular key，如果该Key没有值则找square key值，来决定代理到哪个实际扩展点。当然，由于<code>@Adaptive</code>也支持为空的情况，如果为空，那么根据当前扩展点接口的名称做转换，即如果扩展点接口为<code>RaceCarMaker</code>，那么会变为<code>race.car.maker</code></p><p>5） 扩展点自动激活？</p><p>对于集合类扩展点，比如：Filter, InvokerListener, ExportListener, TelnetHandler, StatusChecker 等，可以同时加载多个实现，此时，可以用自动激活来简化配置，如：</p><pre><code class="java">import org.apache.dubbo.common.extension.Activate;import org.apache.dubbo.rpc.Filter;@Activate // 无条件自动激活public class XxxFilter implements Filter {    // ...}</code></pre><p>或：</p><pre><code class="java">import org.apache.dubbo.common.extension.Activate;import org.apache.dubbo.rpc.Filter;@Activate(&quot;xxx&quot;) // 当配置了xxx参数，并且参数为有效值时激活，比如配了cache=&quot;lru&quot;，自动激活CacheFilter。public class XxxFilter implements Filter {    // ...}</code></pre><p>或：</p><pre><code class="java">import org.apache.dubbo.common.extension.Activate;import org.apache.dubbo.rpc.Filter;@Activate(group = &quot;provider&quot;, value = &quot;xxx&quot;) // 只对提供方激活，group可选&quot;provider&quot;或&quot;consumer&quot;public class XxxFilter implements Filter {    // ...}</code></pre><h3 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h3><p>基本上所有类型的动态导入都是使用adaptive，所以这里以<code>Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>分析：</p><p>使用注解标记该类是扩展SPI</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})public @interface SPI {    /**     * default extension name     */    String value() default &quot;&quot;;}</code></pre><pre><code class="java">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {    // 1. 检查    if (type == null) {        throw new IllegalArgumentException(&quot;Extension type == null&quot;);    }    if (!type.isInterface()) {        throw new IllegalArgumentException(&quot;Extension type (&quot; + type + &quot;) is not an interface!&quot;);    }    if (!withExtensionAnnotation(type)) {        throw new IllegalArgumentException(&quot;Extension type (&quot; + type +                &quot;) is not an extension, because it is NOT annotated with @&quot; + SPI.class.getSimpleName() + &quot;!&quot;);    }    // 2. 尝试从缓存中获取，没有则创建新的并返回    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    if (loader == null) {        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type)); // 触发构造方法        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    }    return loader;}</code></pre><p>先检查有没有带SPI的注解，没有带，直接报错，从缓存中根据这个类型查询对应的ExtensionLoader，查不到就创建一个，再放入缓存中。dubbo中的SPI部分大量利用了本地缓存，后续出现，不再着重讲解了。我们可以看一下他的创建该类型的ExtensionLoader的方法。</p><pre><code class="java">private ExtensionLoader(Class&lt;?&gt; type) {    this.type = type;    /**     * type如果是ExtensionFactory类型，那么objectFactory是null,否则是ExtensionFactory类型的适配器类型     */    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());}</code></pre><p>获取适配的实现：</p><pre><code class="java"> public T getAdaptiveExtension() {    Object instance = cachedAdaptiveInstance.get();    if (instance == null) {        if (createAdaptiveInstanceError == null) {            synchronized (cachedAdaptiveInstance) {                instance = cachedAdaptiveInstance.get();                if (instance == null) {                    try {                        // 从缓存中取，取不到就创建                        instance = createAdaptiveExtension();                        cachedAdaptiveInstance.set(instance);                    } catch (Throwable t) {                        createAdaptiveInstanceError = t;                        throw new IllegalStateException(&quot;Failed to create adaptive instance: &quot; + t.toString(), t);                    }                }            }        } else {            throw new IllegalStateException(&quot;Failed to create adaptive instance: &quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);        }    }    return (T) instance;}</code></pre><p>接下来是获取到适配器类的Class，利用反射创建适配器类的实例。injectExtension是dubbo的DI，依赖注入。如果适配器类有属性即其他扩展点的set方法，会自动注入（扩展点自动装配）。</p><pre><code class="java">private T createAdaptiveExtension() {    try {        return injectExtension((T) getAdaptiveExtensionClass().newInstance()); //反射创建实例    } catch (Exception e) {        throw new IllegalStateException(&quot;Can&#39;t create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);    }}</code></pre><pre><code class="java">private Class&lt;?&gt; getAdaptiveExtensionClass() {    // 扫描SPI，并将可能的实现放入缓存 读取文件加载放入缓存等等    getExtensionClasses();    // 如果通过上面的步骤可以获取到cachedAdaptiveClass直接返回，如果不行的话，就得考虑自己进行利用动态代理创建一个了    if (cachedAdaptiveClass != null) {        return cachedAdaptiveClass;    }    // 利用动态代理创建一个适配类    return cachedAdaptiveClass = createAdaptiveExtensionClass();}</code></pre><p>扫描SPI的代码：</p><pre><code class="java">// 加载文件 extensionClasses 会保存 key=value的映射private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {    // 设置SPI名称中的类key为默认实现    cacheDefaultExtensionName();    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));    return extensionClasses;}</code></pre><p>放入缓存的关键代码：</p><pre><code class="java">private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException {    if (!type.isAssignableFrom(clazz)) {        throw new IllegalStateException(&quot;Error occurred when loading extension class (interface: &quot; +                type + &quot;, class line: &quot; + clazz.getName() + &quot;), class &quot;                + clazz.getName() + &quot; is not subtype of interface.&quot;);    }    // 判断这个加载的类上，有没有Adaptive的注解，如果有缓存这个类的实现，这个缓存决定了动态替换的实现    if (clazz.isAnnotationPresent(Adaptive.class)) {        cacheAdaptiveClass(clazz);    } else if (isWrapperClass(clazz)) {        cacheWrapperClass(clazz);    } else {        ...    }}</code></pre><p>如果cachedAdaptiveClass不为空就返回，什么情况下不为空？当扩展类上打上@Adaptive注解的时候，就会将这个类直接返回。如果没有上注解，怎么办，就得自己生成了，也就是createAdaptiveExtensionClass</p><pre><code class="java">private Class&lt;?&gt; createAdaptiveExtensionClass() {    String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();    ClassLoader classLoader = findClassLoader();    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();    return compiler.compile(code, classLoader);}</code></pre><p>接口Ext6生成的动态代理code大致如下：</p><pre><code>@SPIpublic interface Ext6 {    @Adaptive    String echo(URL url, String s);}</code></pre><pre><code class="java">package org.apache.dubbo.common.extension.ext6_inject;import org.apache.dubbo.common.extension.ExtensionLoader;public class Ext6$Adaptive implements org.apache.dubbo.common.extension.ext6_inject.Ext6 {    public java.lang.String echo( org.apache.dubbo.common.URL arg0, java.lang.String arg1 ){        if ( arg0 == null )            throw new IllegalArgumentException( &quot;url == null&quot; );        org.apache.dubbo.common.URL    url    = arg0;        String    extName = url.getParameter( &quot;ext6&quot; );        // 这里是关键，需要增加参数ext6，value即为具体实现类的key，这样这个动态替换便实现了        if ( extName == null )            throw new IllegalStateException( &quot;Failed to get extension (org.apache.dubbo.common.extension.ext6_inject.Ext6) name from url (&quot; + url.toString() + &quot;) use keys([ext6])&quot; );        org.apache.dubbo.common.extension.ext6_inject.Ext6 extension = (org.apache.dubbo.common.extension.ext6_inject.Ext6)ExtensionLoader.getExtensionLoader( org.apache.dubbo.common.extension.ext6_inject.Ext6.class ).getExtension( extName );        return(extension.echo( arg0, arg1 ) );    }}</code></pre><p>这里的关键是需要增加参数ext6，value即为具体实现类的key，这样这个动态替换便实现了。如何增加参数？</p><pre><code class="java">Ext6 ext = ExtensionLoader.getExtensionLoader(Ext6.class).getAdaptiveExtension();URL url = new URL(&quot;p1&quot;, &quot;1.2.3.4&quot;, 1010, &quot;path1&quot;);url = url.addParameters(&quot;ext6&quot;, &quot;impl1&quot;);  //增加关键参数// 这样其实已经指定实现类 key 为 impl1 的类了impl1=org.apache.dubbo.common.extension.ext6_inject.impl.Ext6Impl1impl2=org.apache.dubbo.common.extension.ext6_inject.impl.Ext6Impl2</code></pre><p>如果是 <code>@Adaptive({&quot;test&quot;,&quot;test2&quot;,&quot;test3&quot;})</code> 这种情况生成的代码：</p><pre><code class="java">String extName = url.getParameter(&quot;test&quot;, url.getParameter(&quot;test2&quot;, url.getParameter(&quot;test3&quot;)));</code></pre><p>就比较有意思了，<code>getParameter(String key, String defaultValue)</code>，先获取test，没找到则test2，最后test3，这也印证了上面的规则。</p><p>所以，我们可以简单的看出一些关于<code>@Adaptive</code>的规则，当标注在实现类上时优先级最高，当标注在方法上时次之，最后才是不标注默认使用扩展接口类名并以.分割作为key.</p><h3 id="简单玩法"><a href="#简单玩法" class="headerlink" title="简单玩法"></a>简单玩法</h3><p>如果想要动态替换掉默认的实现类，需要使用@Adaptive接口，Protocol接口中，有两个方法加了@Adaptive注解，就是说那俩接口会被代理实现。</p><p>比如这个Protocol接口搞了俩@Adaptive注解标注了方法，在运行的时候会针对Protocol生成代理类，这个代理类的那俩方法里面会有代理代码，代理代码会在运行的时候动态根据url中的protocol来获取那个key，默认是dubbo，你也可以自己指定，你如果指定了别的key，那么就会获取别的实现类的实例了。</p><p>通过这个url中的参数不同，就可以控制动态使用不同的组件实现类。</p><p>好吧，那下面来说说怎么来自己扩展dubbo中的组件</p><p>自己写个工程，要是那种可以打成jar包的，里面的src/main/resources目录下，搞一个META-INF/services，里面放个文件叫：com.alibaba.dubbo.rpc.Protocol，文件里搞一个my=io.github.pleuvoir.MyProtocol。自己把jar弄到nexus私服里去。</p><p>然后自己搞一个dubbo provider工程，在这个工程里面依赖你自己搞的那个jar，然后在spring配置文件里给个配置：</p><p>&lt;dubbo:protocol name=”my” port=”20000” /&gt;</p><p>这个时候provider启动的时候，就会加载到我们jar包里的my=io.github.pleuvoir.MyProtocol这行配置里，接着会根据你的配置使用你定义好的MyProtocol了，这个就是简单说明一下，你通过上述方式，可以替换掉大量的dubbo内部的组件，就是扔个你自己的jar包，然后配置一下即可。</p><p>dubbo里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个jar，让你的consumer或者是provider工程，依赖你的那个jar，在你的jar里指定目录下配置好接口名称对应的文件，里面通过key=实现类。</p><p>然后对应的组件，用类似<a href="dubbo:protocol" target="_blank" rel="noopener">dubbo:protocol</a>用你的哪个key对应的实现类来实现某个接口，你可以自己去扩展dubbo的各种功能，提供你自己的实现。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://dubbo.apache.org/zh-cn/docs/dev/SPI.html" target="_blank" rel="noopener" title="dubbo扩展点加载官方文档">http://dubbo.apache.org/zh-cn/docs/dev/SPI.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList 源码分析</title>
      <link href="/2018/03/19/arraylist-yuan-ma-fen-xi/"/>
      <url>/2018/03/19/arraylist-yuan-ma-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h2><h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><pre><code class="java">public class ArrayList extends AbstractList          implements List, RandomAccess, Cloneable, java.io.Serializable  </code></pre><p>实现了 RandomAccess 接口，也就是说支持随机访问，因为 ArrayList 是基于数组实现的。 实际上查看 RandomAccess 的实现发现为空实现标记接口。文档提及，如果一个 List 实现了 RandomAccess 接口，则使用 for 循环遍历的方式会比 Iterator 更快。在平时的开发中，在数据量比较大的时候通过判断List的类型从而选择更优的迭代方式。</p><pre><code class="java">if (arrayList instanceof RandomAccess) {    for (;;) {        // .. ignored    }} else {    Iterator&lt;String&gt; iterator = arrayList.iterator();    while (iterator.hasNext()) {        String s = (String) iterator.next();        // .. ignored    }}</code></pre><p>由于该类基于数组实现，保存元素的数组使用 transient 修饰，表明数组默认不会被序列化。想想 ArrayList 的动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。ArrayList 重写了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。  </p><pre><code class="java">transient Object[] elementData; // non-private to simplify nested class access  </code></pre><pre><code class="java">private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException{    // Write out element count, and any hidden stuff    int expectedModCount = modCount;    s.defaultWriteObject();    // Write out size as capacity for behavioural compatibility with clone()    s.writeInt(size);    // Write out all elements in the proper order.    for (int i=0; i&lt;size; i++) {        s.writeObject(elementData[i]);    }    if (modCount != expectedModCount) {        throw new ConcurrentModificationException();    }}</code></pre><p>数组的默认大小为 10。  </p><pre><code class="java">private static final int DEFAULT_CAPACITY = 10;  </code></pre><p>删除元素时需要调用 System.arraycopy() 对元素进行复制，因此删除操作成本很高。  </p><pre><code class="java">public E remove(int index) {      rangeCheck(index);      modCount++;      E oldValue = elementData(index);      int numMoved = size - index - 1;      if (numMoved &gt; 0)          System.arraycopy(elementData, index+1, elementData, index, numMoved);      elementData[--size] = null; // clear to let GC do its work      return oldValue;  }  </code></pre><p>添加元素时使用 ensureCapacity() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，使得新容量为旧容量的 1.5 倍（oldCapacity + (oldCapacity &gt;&gt; 1))。扩容操作需要把原数组整个复制到新数组中，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。  </p><pre><code class="java">private void ensureExplicitCapacity(int minCapacity) {      modCount++;      // overflow-conscious code      if (minCapacity - elementData.length &gt; 0)          grow(minCapacity);  }  private void grow(int minCapacity) {      // overflow-conscious code      int oldCapacity = elementData.length;      int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);      if (newCapacity - minCapacity &lt; 0)          newCapacity = minCapacity;      if (newCapacity - MAX_ARRAY_SIZE &gt; 0)          newCapacity = hugeCapacity(minCapacity);      // minCapacity is usually close to size, so this is a win:      elementData = Arrays.copyOf(elementData, newCapacity);  }  </code></pre><h3 id="2-Fail-Fast"><a href="#2-Fail-Fast" class="headerlink" title="2. Fail-Fast"></a>2. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，修改元素的值不算。    </p><p>在进行序列化 ，迭代等操作时，会比较操作前后 modCount 是否改变，如果改变了会抛出ConcurrentModificationException。   </p><p>在并行的情况下，可能会抛出该异常，文档中提及并不能保证该特性有效，所以不能依赖该异常来做判断，仅仅作为检测bug来使用是合理的。  </p><p>如果需要一个线程安全的实现，可以这样，本质上是用synchronized来处理的。  </p><pre><code class="java">List arrayList = new ArrayList();  List synchronizedList = Collections.synchronizedList(arrayList);  </code></pre><h3 id="3-和-LinkedList-的区别"><a href="#3-和-LinkedList-的区别" class="headerlink" title="3. 和 LinkedList 的区别"></a>3. 和 LinkedList 的区别</h3><ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向循环链表实现；  </li><li>ArrayList 支持随机访问，LinkedList 不支持；  </li><li>LinkedList 在任意位置添加删除元素更快。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程基础</title>
      <link href="/2018/02/08/wang-luo-bian-cheng-ji-chu/"/>
      <url>/2018/02/08/wang-luo-bian-cheng-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>OSI 采用了分层的结构化技术，共分七层，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><p><img src="https://i.imgur.com/2BxC7Sf.png" alt=""></p><h2 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h2><p>通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。</p><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。</p><p>TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。</p><p>如果IP数据包中有已经封好的TCP数据包，那么IP将把它们向‘上’传送到TCP层。TCP将包排序并进行错误检查，同时实现虚电路间的连接。TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序，而损坏的包可以被重传。<br>TCP将它的信息送到更高层的应用程序，例如Telnet的服务程序和客户程序。应用程序轮流将信息送回TCP层，TCP层便将它们向下传送到IP层，设备驱动程序和物理介质，最后到接收方。</p><p>面向连接的服务（例如Telnet、FTP、rlogin、X Windows和SMTP）需要高度的可靠性，所以它们使用了TCP。DNS在某些情况下使用TCP（发送和接收域名数据库），但使用UDP传送有关单个主机的信息。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。</p><p>UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。</p><p>UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。使用UDP的服务包括NTP（网络时间协议）和DNS（DNS也使用TCP），包总量较少的通信（DNS、SNMP等）；2.视频、音频等多媒体通信（即时通信）；3.限定于 LAN 等特定网络中的应用通信；4.广播通信（广播、多播）。<br>常用QQ，就是一个以UDP为主，TCP为辅的通讯协议。</p><h3 id="TCP-和-UDP-的优缺点"><a href="#TCP-和-UDP-的优缺点" class="headerlink" title="TCP 和 UDP 的优缺点"></a>TCP 和 UDP 的优缺点</h3><p>无法简单地、绝对地去做比较：TCP 用于在传输层有必要实现可靠传输的情况；而在一方面，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信。TCP 和 UDP 应该根据应用的目的按需使用。</p><h3 id="TCP-中通过序列号与确认应答提高可靠性"><a href="#TCP-中通过序列号与确认应答提高可靠性" class="headerlink" title="TCP 中通过序列号与确认应答提高可靠性"></a>TCP 中通过序列号与确认应答提高可靠性</h3><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到消息的通知。这个消息叫做确认应答（ACK）。当发送端将数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。反之，则数据丢失的可能性很大。</p><p>在一定时间内没有等待到确认应答，发送端就可以认为数据已经丢失，并进行重发。由此，即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。<br>未收到确认应答并不意味着数据一定丢失。也有可能是数据对方已经收到，只是返回的确认应答在途中丢失。这种情况也会导致发送端误以为数据没有到达目的地而重发数据。</p><p>此外，也有可能因为一些其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源主机只要按照机制重发数据即可。</p><p>对于目标主机来说，反复收到相同的数据是不可取的。为了对上层应用提供可靠的传输，目标主机必须放弃重复的数据包。为此我们引入了序列号。</p><p>序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号。接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答返送回去。通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</p><p><img src="https://i.imgur.com/we5IZyq.png" alt=""></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。</p><p>所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。<br>第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</p><p>第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p><p>第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p><h2 id="HTTP请求的传输过程"><a href="#HTTP请求的传输过程" class="headerlink" title="HTTP请求的传输过程"></a>HTTP请求的传输过程</h2><p>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p><p>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p><p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</p><h2 id="一次完整http请求的7个过程"><a href="#一次完整http请求的7个过程" class="headerlink" title="一次完整http请求的7个过程"></a>一次完整http请求的7个过程</h2><ul><li><p>建立 TCP 连接<br>在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80； </p></li><li><p>客户端向服务器发送请求命令<br>一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：GET/sample/hello.jsp HTTP/1.1 </p></li><li><p>客户端发送请求头信息<br>客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送； </p></li><li><p>服务器应答<br>客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： HTTP/1.1 200 OK<br>响应的第一部分是协议的版本号和响应状态码 </p></li><li><p>服务器返回响应头信息<br>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档； </p></li><li><p>服务器向客户端发送数据<br>服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据； </p></li><li><p>服务器关闭 TCP 连接<br>一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 容器概览</title>
      <link href="/2018/01/08/java-rong-qi-gai-lan/"/>
      <url>/2018/01/08/java-rong-qi-gai-lan/</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>容器主要包括 Collection 和 Map 两种，Collection 又包含了 List、Set 以及 Queue。  </p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><ul><li><p>HashSet：基于哈希实现，支持快速查找，但不支持有序性操作，例如根据一个范围查找元素的操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。  </p></li><li><p>TreeSet：基于红黑树实现，支持有序性操作，但是查找效率不如 HashSet，HashSet 查找时间复杂度为 O(1)，TreeSet 则为 O(logn)；  </p></li><li><p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用链表维护元素的插入顺序。  </p></li></ul><h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul><li><p>ArrayList：基于动态数组实现，支持随机访问；  </p></li><li><p>Vector：和 ArrayList 类似，但它是线程安全的；  </p></li><li><p>LinkedList：基于双向循环链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双端队列。  </p></li></ul><h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul><li><p>LinkedList：可以用它来支持双向队列；  </p></li><li><p>PriorityQueue 是基于堆结构实现，可以用它来实现优先级队列。  </p></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><p>HashMap：基于哈希实现；  </p></li><li><p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。  </p></li><li><p>LinkedHashMap：使用链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  </p></li><li><p>TreeMap：基于红黑树实现。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ 安装</title>
      <link href="/2017/09/28/rabbitmq-an-zhuang/"/>
      <url>/2017/09/28/rabbitmq-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>在 Linux 中安装 RabbitMQ 演示 操作系统版本为 <code>CentOS7</code></p><h3 id="安装-erlang-和-RabbitMQ"><a href="#安装-erlang-和-RabbitMQ" class="headerlink" title="安装 erlang 和 RabbitMQ"></a>安装 erlang 和 RabbitMQ</h3><pre><code># 切换用户，这一步看情况su - root## 安装wget https://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm// 如果失败，那么继续执行下一条rpm -Uvh erlang-solutions-1.0-1.noarch.rpmyum install epel-releaseyum install erlangwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.6/rabbitmq-server-3.6.6-1.el7.noarch.rpmyum install rabbitmq-server-3.6.6-1.el7.noarch.rpm</code></pre><p>至此， <code>RabbitMQ</code> 已经安装完成了，现在我们把它启动一下。因为是直接下载，所以可能会失败是正常的，多次尝试即可。</p><h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h3><pre><code># 启动service rabbitmq-server start# 查看状态service rabbitmq-server status# 安装管理控制台rabbitmq-plugins enable rabbitmq_management  # 如果需要做推送可以开启 stomp 代理（这一步不是必须的）rabbitmq-plugins enable rabbitmq_web_stomp# 重启RabbitMQservice rabbitmq-server stopservice rabbitmq-server start# 开启相对应的端口，方便外网查看 （如果是 aliyun 可以参考开放端口 https://jingyan.baidu.com/article/03b2f78c31bdea5ea237ae88.html） （如果压根就没开启可以参考进行开启，当然下面的两行也就不需要了 https://jingyan.baidu.com/article/5552ef47f509bd518ffbc933.html）firewall-cmd --permanent --add-port=15672/tcpfirewall-cmd --permanent --add-port=5672/tcp# 查看已有虚拟主机并增加名为 cc 的虚拟主机rabbitmqctl list_vhostsrabbitmqctl add_vhost ccrabbitmqctl list_vhosts# 增加名为 pleuvoir 的用户并配置 administrator 角色并增加相应的权限rabbitmqctl add_user pleuvoir 123456rabbitmqctl set_permissions -p cc pleuvoir &#39;.*&#39; &#39;.*&#39; &#39;.*&#39;rabbitmqctl set_user_tags  pleuvoir  administrator</code></pre><p>登录 host:15672 即可查看管理控制台</p><p>如果需要在 windows 下安装，可以参考 <a href="https://github.com/pleuvoir/reference-samples/tree/master/spring-amqp-example" target="_blank" rel="noopener">windows 下安装 RabbitMQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring 读取配置文件的多种方式</title>
      <link href="/2017/05/24/spring-du-qu-pei-zhi-wen-jian-de-duo-chong-fang-shi/"/>
      <url>/2017/05/24/spring-du-qu-pei-zhi-wen-jian-de-duo-chong-fang-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、使用-Value"><a href="#一、使用-Value" class="headerlink" title="一、使用 @Value"></a>一、使用 @Value</h3><p>注意：</p><p>项目中必须有一个配置类声明了 <code>@PropertySource(value = { &quot;xxx.properties&quot; })</code>, 当然如下这样也是可以的。</p><pre><code class="xml">&lt;context:property-placeholder            location=&quot;classpath:config/dev/database-dev.properties,                      classpath:config/dev/rabbitmq-dev.properties&quot;/&gt;</code></pre><p>如果没有声明并且 <code>filed</code> 皆为 <code>string</code> 类型，项目启动的时候可能不会报错，但是使用时会发现对应的 <code>filed</code> 值并没有被解析，而是原始表达式如 <code>${example.name}</code> 。<br>如果 <code>filed</code> 有非 <code>string</code> 类型的值，则启动时会报类型转换异常的错。</p><p>使用如下所示：</p><pre><code class="java">@Value(value = &quot;${example.name}&quot;)private String name;@Value(value = &quot;${example.version}&quot;)private Integer version;@Value(value = &quot;${example.isfinish}&quot;)private boolean isFinish;@Value(value = &quot;#{20-2}&quot;)private Integer age;</code></pre><p>如果属性过于多，建议进行封装，不要在需要用到值的地方声明太多，看着不清爽。</p><h3 id="二、使用-Environment"><a href="#二、使用-Environment" class="headerlink" title="二、使用 Environment"></a>二、使用 Environment</h3><p>spring 中提供的基础方法，这里按下不表；示例中提供了包装类的实现。</p><h3 id="三、指定-location-读取"><a href="#三、指定-location-读取" class="headerlink" title="三、指定 location 读取"></a>三、指定 location 读取</h3><p>经常要写一些工具类，而这些工具类依赖于配置文件，则可以使用 spring 提供的工具类进行读取。</p><pre><code class="java">PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();Resource resource = resolver.getResource(location);Properties pro = PropertiesLoaderUtils.loadProperties(resource);PropertiesWrap proWrap = new PropertiesWrap(pro);</code></pre><p>这种可以一次读取多个文件</p><pre><code class="java">@Bean(name = &quot;appProperties&quot;)public Properties configProperties() throws Exception {    PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();    // 1//        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();//        propertiesFactoryBean.setLocations(resolver.getResource(&quot;classpath:dev.properties&quot;),//                resolver.getResource(&quot;classpath:groovy.properties&quot;));    // 2    propertiesFactoryBean.setLocations(new ClassPathResource(&quot;dev.properties&quot;), new ClassPathResource(&quot;groovy.properties&quot;));    propertiesFactoryBean.afterPropertiesSet();    Properties appProperties = propertiesFactoryBean.getObject();    return appProperties;}</code></pre><p>示例： <a href="https://github.com/pleuvoir/reference-samples/tree/master/spring-annotation-based-example/src/main/java/io/github/pleuvoir/chapter7" target="_blank" rel="noopener">https://github.com/pleuvoir/reference-samples/tree/master/spring-annotation-based-example/src/main/java/io/github/pleuvoir/chapter7</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（三） 解决跨域</title>
      <link href="/2016/09/30/nginx-san-jie-jue-kua-yu/"/>
      <url>/2016/09/30/nginx-san-jie-jue-kua-yu/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器跨域问题"><a href="#浏览器跨域问题" class="headerlink" title="浏览器跨域问题"></a>浏览器跨域问题</h3><p>跨域是指从一个域名的网页去请求另一个域名的资源。</p><p>添加header头： Access-Control-Allow-Origin，表明允许网站执行</p><p>简单请求：<br>浏览器在跨源AJAX请求的头信息之中，自动在添加一个Origin字段（本次请求来自哪个源 ）。服务器根据这个值，在许可范围内，则在头信息包含 Access-Control-Allow-Origin 。</p><p>复杂请求：<br>会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求OPTIONS </p><h4 id="1-通过反向代理"><a href="#1-通过反向代理" class="headerlink" title="1. 通过反向代理"></a>1. 通过反向代理</h4><p>让前端 ajax 请求自己项目中的地址，通过 proxy_pass 转发到真实的服务器</p><h4 id="2-Cors-解决方案"><a href="#2-Cors-解决方案" class="headerlink" title="2. Cors 解决方案"></a>2. Cors 解决方案</h4><p>只要响应中有header头： Access-Control-Allow-Origin，表明允许网站执行</p><p><img src="https://i.imgur.com/vmMzBpk.png" alt=""></p><p>案例:</p><p>a、当 chrome 发现 ajax 请求的网址，与当前主域名不一致（跨域）时，会在请求 header 中追加值页面主域名值，如：origin = <a href="http://static.pleuvoir.cn" target="_blank" rel="noopener">http://static.pleuvoir.cn</a></p><p>b、nginx 在接收到 ajax 请求时，会查看 origin 值，即请求我的网址是谁？此处使用正则来校验，即：只要是 pleuvoir.cn 下的网址，都允许访问我。返回信息时，nginx 追加 header 值：access-control-allow-origin = static.pleuvoir.cn（回答浏览器，这个域名网址可以访问我）</p><p>nginx.conf 配置如下，这段配置直接贴也基本没问题，只需要修改下一级域名:</p><pre><code>listen  80;server_name  pleuvoir.cn;# $http_origin 内置变量 = a 中 origin 的值if ( $http_origin ~ http://(.*).pleuvoir.cn){     set $allow_url $http_origin;}#是否允许请求带有验证信息add_header Access-Control-Allow-Credentials true;#允许跨域访问的域名,可以是一个域的列表，也可以是通配符*add_header Access-Control-Allow-Origin  $allow_url;  #（重要）这里就是 nginx 的回答了，允许域名下网页访问#允许脚本访问的返回头add_header Access-Control-Allow-Headers &#39;x-requested-with,content-type,Cache-Control,Pragma,Date,x-timestamp&#39;;#允许使用的请求方法，以逗号隔开add_header Access-Control-Allow-Methods &#39;POST,GET,OPTIONS,PUT,DELETE&#39;;#允许自定义的头部，以逗号隔开,大小写不敏感add_header Access-Control-Expose-Headers &#39;WWW-Authenticate,Server-Authorization&#39;;#P3P支持跨域cookie操作add_header P3P &#39;policyref=&quot;/w3c/p3p.xml&quot;, CP=&quot;NOI DSP PSAa OUR BUS IND ONL UNI COM NAV INT LOC&quot;&#39;;add_header test  1;if ($request_method = &#39;OPTIONS&#39;) {     return 204;}</code></pre><p>c、chrome 收到 ajax 返回值后，查看返回的 header中 access-control-allow-origin 的值，发现其中的值是 static.pleuvoir.cn,正是当前的页面主域名。这是允许访问，于是执行ajax返回值内容。（ps：若此处access-control-allow-origin不存在，或者值不是static域名，chrome就拒绝执行返回值）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（二） 配置</title>
      <link href="/2016/09/29/nginx-er-pei-zhi/"/>
      <url>/2016/09/29/nginx-er-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="一、-目录结构"><a href="#一、-目录结构" class="headerlink" title="一、 目录结构"></a>一、 目录结构</h3><p>源码包编译以后的目录结构如下：</p><p>•    conf   配置文件<br>•    html   静态网页文件（存放静态文件，做静态资源服务）<br>•    logs   日志文件<br>•    sbin   二进制程序</p><p>nginx 中最重要的配置文件是 conf 中的 <code>nginx.conf</code>，基本上以后只需要和它打交道。</p><h3 id="二、-nginx-启停"><a href="#二、-nginx-启停" class="headerlink" title="二、 nginx 启停"></a>二、 nginx 启停</h3><pre><code class="bash">进入 sbin# 检测配置文件是否有错误./nginx -t # 指定配置文件启动，一般是 NGINX_HOME 下 /conf/nginx.conf./nginx -c [nginx.conf文件]# 停止./nginx -s stop  # 退出./nginx -s quit# 重新加载 nginx.conf./nginx -s reload </code></pre><h3 id="三、-nginx-conf-配置文件结构"><a href="#三、-nginx-conf-配置文件结构" class="headerlink" title="三、 nginx.conf 配置文件结构"></a>三、 nginx.conf 配置文件结构</h3><p>main（全局设置）<br>events 设定 nginx 的工作模式及连接数上限<br>http 服务器相关属性<br>server （虚拟主机设置）<br>upstream （上游服务器设置，主要为反向代理、负载均衡相关配置）<br>location （URL匹配特定位置后的设置）</p><p><img src="https://i.imgur.com/wVQmJiM.png" alt="nginx 配置文件结构"></p><pre><code>#user  nobody;                  #主模块命令， 指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。worker_processes  1;            #指定Nginx要开启的进程数。worker_rlimit_nofile 100000;    #worker进程的最大打开文件数限制#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {use epoll;worker_connections  1024;}以上这块配置代码是对nginx全局属性的配置。user: 主模块命令，指定Nginx的worker进程运行用户以及用户组，默认由nobody账号运行。    worker_processes: 指定Nginx要开启的进程数。error log:用来定义全局错设日志文件的路径和日志名称。日志输出级别有debug，info，notice，warn，error，crit 可供选择，其中debug输出日志最为详细，面crit（严重）输出日志最少。默认是errorpid: 用来指定进程id的存储文件位置。event：设定nginx的工作模式及连接数上限，其中参数use用来指定nginx的工作模式（这里是epoll，epoll是多路复用IO(I/O Multiplexing)中的一种方式）,nginx支持的工作模式有select ,poll,kqueue,epoll,rtsig,/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，对于linux系统，epoll是首选。worker_connection是设置nginx每个进程最大的连接数，默认是1024，所以nginx最大的连接数max_client=worker_processes * worker_connections。进程最大连接数受到系统最大打开文件数的限制，需要设置ulimit。</code></pre><h3 id="四、-location-规则"><a href="#四、-location-规则" class="headerlink" title="四、 location 规则"></a>四、 location 规则</h3><p>语法规则： location [=|<del>|</del>*|^~] /uri/ {… }</p><table><thead><tr><th align="left">符号</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">= 开头表示精确匹配（完全相同也算精准匹配）</td></tr><tr><td align="left">^~</td><td align="left">（一般匹配）^<del>开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^</del> /static/ /aa匹配到（注意是空格），匹配完成不再进行正则匹配</td></tr><tr><td align="left">~</td><td align="left">~ 开头表示区分大小写的正则匹配</td></tr><tr><td align="left">~*</td><td align="left">~* 开头表示不区分大小写的正则匹配</td></tr><tr><td align="left">!<del>和!</del>*</td><td align="left">!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配的正则</td></tr><tr><td align="left">/</td><td align="left">用户所使用的代理（一般为浏览器）</td></tr><tr><td align="left">$http_x_forwarded_for</td><td align="left">可以记录客户端IP，通过代理服务器来记录客户端的ip地址</td></tr><tr><td align="left">$http_referer</td><td align="left">可以记录用户是从哪个链接访问过来的</td></tr></tbody></table><p>优先级</p><p>普通匹配location：<br>无前缀：达到完整匹配，也是=<br>“=”<br>“^~” </p><p>普通匹配满足最长匹配原则</p><p>正则匹配location：<br>“<del>“ 表示区分大小写；<br>“</del>*”表示不区分大小写</p><p><img src="https://i.imgur.com/tiKDPkw.png" alt=""></p><h3 id="五、配置文件分离"><a href="#五、配置文件分离" class="headerlink" title="五、配置文件分离"></a>五、配置文件分离</h3><p><code>nginx</code>中配置多个<code>server(虚拟主机)</code>，为了方便维护，会将文件单独提取出来，通过导入的形式使其生效。</p><p>创建配置文件存放目录</p><pre><code>mkdir /etc/nginxmkdir /etc/nginx/conf.dcd /etc/nginx/conf.d/# 创建一个最基础的文件（常规的nginx服务）vi www.conf</code></pre><p>复制以下内容并保存</p><pre><code>server {listen       8080;    # 监听 8080 端口server_name  39.105.110.40;    # 监听此 ip 的访问（一般为入口ip）location /a {                        # 如果请求的后缀是 /a 即使不加 = 也是精准匹配        rewrite ^/  /a.html break;    #  /a 请求返回  html/static/路径下的 a 页面        root   html/static/;        # 这里表示 a.html 在这个目录下    }location /b/a {                rewrite ^/  /b.html break;    # /b/a 或 /b/a/1 请求返回 b 页面        root   html/static/;      }location /b/d/a {        rewrite ^/  /d.html break;    # /b/d/a 或 /b/d/a/1 请求返回 c 页面（这里有点不符合常理，原因是精准匹配后依然后走下面的正则匹配，所以给我们看起来像是正则匹配的优先级高一样）        root   html/static/;    }location ^~/b/c/a {        # 匹配 uri 路径（常用）        rewrite ^/  /d.html break;    # /b/c/a 或 /b/c/a/1 请求返回 d 页面        root   html/static/;    }location ~ /b/d {        rewrite ^/  /c.html break;    # /b/d 或 /b/d/1 或 /b/d/a 请求返回 c 页面        root   html/static/;    }location ~ /b/d/a {        rewrite ^/  /a.html break;        root   html/static/;    }}</code></pre><p>修改 <code>ngxin.conf</code> 增加导入配置，当然需要删除原来相同的配置</p><pre><code>include /etc/nginx/conf.d/*.conf;</code></pre><p>重启以后，测试。</p><p>其中 <code>server_name</code> 可以是域名。可以通过修改 <code>windows hosts文件解析成域名，格式如此: 39.105.110.40 pleuvoir.cn</code>，注意不能加端口。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><pre><code>location /tweets {    proxy_pass https://www.oschina.net/;}</code></pre><p>注意地址后面有没有 <code>/</code>，如果带了斜杠，表示标签是关闭的，那么 location 的 <code>/tweets</code> 不会自动带在需要访问的原始地址后面，即：如果我们目标访问地址是<code>https://www.oschina.net/tweets</code>，那么如果带了斜杠，请求地址应该为<code>pleuvoir.cn:8080/tweets/tweets</code>，此时<code>tweets</code>是不会传递到<code>tomcat</code>的后台，也就是说<code>https://www.oschina.net/ = pleuvoir.cn:8080/tweets</code>。如果没有，那么访问地址是<code>http://pleuvoir.cn:8080/tweets</code>。这里为了演示，location 的匹配直接用了 tweets，实际情况不是一样的。通过其他的规则去匹配然后再决定要不要加上这个<code>/</code>。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>1、轮询（默认）</p><pre><code>upstream nginx {server 172.17.0.4:8081;server 172.17.0.5:8081;}</code></pre><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>2、weight</p><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。down 暂时不参与负载。例如：</p><pre><code>upstream nginx {server 172.17.0.4:8081 weight=2;server 172.17.0.5:8081 weight=1;}</code></pre><p>3、ip_hash</p><p>每个请求按访问ip的hash结果分配，这样同一客户端的请求总是发往同一个后端服务器，可以解决session的问题。例如：</p><pre><code>upstream nginx {ip_hash;server 172.17.0.4:8081;server 172.17.0.5:8081;}</code></pre><p>演示一套负载均衡的配置，需求如下:</p><p>172.17.0.2作为代理nginx<br>172.17.0.3作为静态服务器，读html文件<br>172.17.0.4为后台服务器1，提供web服务<br>172.17.0.5为后台服务器2，提供web服务</p><pre><code># 1upstream nginx {server 172.17.0.4:8081 weight=2;server 172.17.0.5:8081 weight=1;}server {        listen       8080;        server_name  172.17.0.2;            location /nginx {                proxy_pass http://nginx; # 对应 1 处的别名        }        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }    }html代理：location /static {    proxy_pass http://172.17.0.3/; #这里是转发到另外一台服务器，由它来提供静态文件}</code></pre><h4 id="gzip-压缩"><a href="#gzip-压缩" class="headerlink" title="gzip 压缩"></a>gzip 压缩</h4><p>对输出到客户端的内容进行压缩，以减小传输文件体积，减少对网络带宽的占用。服务器端要压缩，客户端必须解压缩，这都将占用cpu时间。不过，由于传输内容减小了，传输过程中，各网卡、路由器、交换机对数据包的处理时间也会缩短。gzip压缩是就在这里赢得了时间。</p><p>必须满足以下几个条件：</p><p>1、客户端发送的HTTP报头必须含有 “Accept-Encoding” 字段，且其值包含 “gzip” 这个压缩类型。<br>一般浏览器都会发 “Accept-Encoding:gzip, deflate, sdch” 这样的报头。</p><p>2、服务器启用了gzip压缩，那么响应头会包含 Content-Encoding:gzip， 客户端根据这个来判断服务器返回的内容是否真正为gzip压缩过的内容。</p><p>gzip压缩对文本文件压缩效果非常好（40%～80%），而对图片文件效果甚微。实际应用中可以考虑对js、html、css格式的文件开启gzip压缩。</p><pre><code>location ~ /(.*)\.(html|js|css|jpg|jpeg|png|gif)$ {    gzip on; # 启用gzip压缩，默认是off，不启用    # 对js、css、jpg、png、gif格式的文件启用gzip压缩功能    gzip_types application/javascript text/css image/jpeg image/png image/gif;    gzip_min_length 1024; # 所压缩文件的最小值，小于这个的不会压缩    gzip_buffers 4 1k; # 设置压缩响应的缓冲块的大小和个数，默认是内存一个页的大小    gzip_comp_level 1; # 压缩水平，默认1。取值范围1-9，取值越大压缩比率越大，但越耗cpu时间    root html/gzip; # 这行和 gzip 压缩无关，表示文件目录}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx（一） 简介与安装</title>
      <link href="/2016/09/28/nginx-yi-jian-jie-yu-an-zhuang/"/>
      <url>/2016/09/28/nginx-yi-jian-jie-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Nginx-简介"><a href="#一、Nginx-简介" class="headerlink" title="一、Nginx 简介"></a>一、Nginx 简介</h3><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><p>Apache 仍然是市场占用量最高的 web 服务器，据最新数据统计，市场占有率目前是 50% 左右。主要优势在于一个是比较早出现的一个 Http 静态资源服务器，同时又是开源的。所以在技术上的支持以及市面上的各种解决方案都比较成熟。Apache 支持的模块非常丰富。</p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><p>Nginx 是俄罗斯人编写的一款高性能的 HTTP 和反向代理服务器，在高连接并发的情况下，它能够支持高达 50000 个并发连接数的响应，但是内存、CPU 等系统资源消耗却很低，运行很稳定。目前 Nginx 在国内很多大型企业都有应用，据最新统计，Nginx 的市场占有率已经到 33% 左右了。而 Apache 的市场占有率虽然仍然是最高的，但是是呈下降趋势。而 Nginx 的势头很明显。选择 Nginx 的理由也很简单：第一，它可以支持 5W 高并发连接；第二，内存消耗少；第三，成本低，如果采用 F5、NetScaler 等硬件负载均衡设备的话，需要大几十万。而 Nginx是开源的，可以免费使用并且能用于商业用途。</p><h3 id="二、架构中的作用"><a href="#二、架构中的作用" class="headerlink" title="二、架构中的作用"></a>二、架构中的作用</h3><p>nginx 在系统架构（网关入口）中的作用，总结如下：</p><ol><li>路由功能（与微服务对应）：域名/路径，进行路由选择后台服务器</li><li>负载功能（与高并发高可用对应）：对后台服务器集群进行负载</li><li>静态服务器（比 tomcat 性能高很多）：将静态文件单独做一个服务器；在 mvvm 模式中，充当文件读取职责</li></ol><p>总结：实际使用中，这三种功能会混合使用。比如先分离动静，再路由服务，再负载机器。</p><h3 id="三、正向代理与反向代理"><a href="#三、正向代理与反向代理" class="headerlink" title="三、正向代理与反向代理"></a>三、正向代理与反向代理</h3><ol><li><p>代理：客户端自己请求出现困难。客户请了一个代理，来代自己做事，就叫正向代理。<br> 比如代理律师，代购，政府机关办事的代理人等等。</p></li><li><p>反向代理，服务端推出的一个代理招牌（服务器请来的）。</p></li></ol><h3 id="四、Nginx-安装"><a href="#四、Nginx-安装" class="headerlink" title="四、Nginx 安装"></a>四、Nginx 安装</h3><h4 id="源码编译安装方式（推荐）"><a href="#源码编译安装方式（推荐）" class="headerlink" title="源码编译安装方式（推荐）"></a>源码编译安装方式（推荐）</h4><pre><code class="bash"># 进入自己准备存放下载文件的目录cd /user/local/src# 如果 wget 不能用，可先安装 yun -y install wgetwget http://nginx.org/download/nginx-1.9.15.tar.gz# 下载完成后解压tar zxvf nginx-1.9.15.tar.gz# 按顺序安装依赖## 正则相关yum -y install pcre pcre-devel    yum -y install zlib zlib-devel## https 相关yum install -y openssl openssl-devel# 进入cd nginx-1.9.15# 编译，指定安装位置 /usr/local/nginx，指定安装模块 https./configure   --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module # 当出现 creating objs/Makefile 表示编译成功，然后安装make &amp;&amp; make install# 查看 nginx 安装后的位置whereis nginx（// 此时在 nginx: /usr/local/nginx）</code></pre><p>至此 nginx 就安装完成了。进入安装后的目录，执行 <code>sbin/nginx</code> 启动，如果 80 端口没有被占用那么访问服务器 ip，就能看见 nginx 的欢迎页</p><h4 id="yum-方式（简单但不建议使用）"><a href="#yum-方式（简单但不建议使用）" class="headerlink" title="yum 方式（简单但不建议使用）"></a>yum 方式（简单但不建议使用）</h4><pre><code class="bash"># centos6 系统是红帽，它维护了一个 yum 扩展源，但是这个没原始的包那么安全，并且依赖比较分散yum install epel-release -y  yum install nginx -y</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
